This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.dockerignore
.gitignore
app/auth/actions.ts
app/auth/callback/route.ts
app/globals.css
app/layout.tsx
app/login/page.tsx
app/movies/[category]/loading.tsx
app/movies/[category]/page.tsx
app/movies/detail/[id]/loading.tsx
app/movies/detail/[id]/page.tsx
app/page.tsx
app/profile/actions.ts
app/profile/page.tsx
app/search/loading.tsx
app/search/page.tsx
app/signup/page.tsx
app/watchlist/actions.ts
app/watchlist/page.tsx
components.json
components/auth/auth-form-wrapper.tsx
components/auth/login-form.tsx
components/auth/search-param-error-display.tsx
components/auth/signup-form.tsx
components/auth/update-password-form.tsx
components/auth/update-profile-form.tsx
components/auth/user-button.tsx
components/dark-mode-toggle.tsx
components/footer.tsx
components/MediaCard.tsx
components/MediaGrid.tsx
components/SearchInput.tsx
components/skeletons/MediaGridSkeleton.tsx
components/skeletons/MovieDetailSkeleton.tsx
components/theme-provider.tsx
components/ui/aspect-ratio.tsx
components/ui/avatar.tsx
components/ui/badge.tsx
components/ui/button.tsx
components/ui/card.tsx
components/ui/dropdown-menu.tsx
components/ui/input.tsx
components/ui/label.tsx
components/ui/pagination.tsx
components/ui/sonner.tsx
components/ui/tabs.tsx
components/watchlist-button.tsx
docker-compose.yml
Dockerfile
eslint.config.mjs
lib/supabase/client.ts
lib/supabase/middleware.ts
lib/supabase/server.ts
lib/tmdb.ts
lib/utils.ts
middleware.ts
next.config.ts
open-next.config.ts
package.json
postcss.config.mjs
public/Alt_Short_Blue.svg
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
README.md
tsconfig.json
wrangler.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".dockerignore">
# Don't include your environment variables
.env

# Don't include node_modules — it's installed in the Docker image
node_modules

# Ignore build output
.next
out

# Ignore local development files
npm-debug.log
yarn-debug.log
yarn-error.log
*.swp
*.swo

# OS-specific files
.DS_Store
Thumbs.db

# Git and VCS
.git
.gitignore

# Docker-specific
docker-compose.override.yml
</file>

<file path="app/auth/actions.ts">
// app/auth/actions.ts
"use server";

import { createClient } from "@/lib/supabase/server";
import { headers } from "next/headers";
import { redirect } from "next/navigation";
import { z } from "zod";

const emailSchema = z.string().email({ message: "Invalid email address." });
const passwordSchema = z
  .string()
  .min(8, { message: "Password must be at least 8 characters long." });

const signupSchema = z.object({
  email: emailSchema,
  password: passwordSchema,
});

const loginSchema = z.object({
  email: emailSchema,
  password: passwordSchema,
});

// Define a type for the state managed by useFormState
type ZodFieldErrors = {
  [key: string]: string[] | undefined;
};

export type FormActionState = {
  error?: string;
  fieldErrors?: ZodFieldErrors;
  success?: boolean; // Used by signUpWithEmail
  message?: string; // Used by signUpWithEmail
} | null; // Crucially, allow null to match initialState and for initial calls

export async function signUpWithEmail(
  prevState: FormActionState, // Use the defined state type
  formData: FormData
): Promise<FormActionState> {
  // Action returns the same state type
  const supabase = createClient();
  const origin = (await headers()).get("origin");

  const validatedFields = signupSchema.safeParse({
    email: formData.get("email"),
    password: formData.get("password"),
  });

  if (!validatedFields.success) {
    return {
      error: "Invalid form data.",
      fieldErrors: validatedFields.error.flatten().fieldErrors,
    };
  }

  const { email, password } = validatedFields.data;

  const { error } = await (
    await supabase
  ).auth.signUp({
    email,
    password,
    options: {
      emailRedirectTo: `${origin}/auth/callback`,
    },
  });

  if (error) {
    console.error("Sign up error:", error);
    return { error: error.message || "Could not authenticate user." };
  }

  return { success: true, message: "Check your email to confirm sign up." };
}

export async function signInWithEmail(
  prevState: FormActionState, // Use the defined state type
  formData: FormData
): Promise<FormActionState> {
  // Action returns the same state type
  const supabase = createClient();

  const validatedFields = loginSchema.safeParse({
    email: formData.get("email"),
    password: formData.get("password"),
  });

  if (!validatedFields.success) {
    return {
      error: "Invalid form data.",
      fieldErrors: validatedFields.error.flatten().fieldErrors,
    };
  }

  const { email, password } = validatedFields.data;

  const { error: authError } = await (
    await supabase
  ).auth.signInWithPassword({
    email,
    password,
  });

  if (authError) {
    console.error("Sign in error:", authError);
    return { error: authError.message || "Could not authenticate user." };
  }

  // If login is successful, Supabase sets a cookie.
  // The redirect will then happen. redirect() throws an error that Next.js handles.
  // This means the function won't "return" in the traditional sense after this call.
  // The Promise<FormActionState> is satisfied because this path doesn't complete normally.
  redirect("/");
}

// signInWithGoogle is not typically used with useFormState in the same way,
// as it involves a browser redirect. Its return type can be more specific to its needs.
export async function signInWithGoogle(): Promise<{
  success?: boolean;
  url?: string;
  error?: string;
}> {
  const supabase = createClient();
  const origin = (await headers()).get("origin");

  const { data, error } = await (
    await supabase
  ).auth.signInWithOAuth({
    provider: "google",
    options: {
      redirectTo: `${origin}/auth/callback`,
    },
  });

  if (error) {
    console.error("Google sign in error:", error);
    return { error: "Could not authenticate with Google." };
  }

  if (data.url) {
    return { success: true, url: data.url };
  }
  return { error: "Google sign in failed unexpectedly." };
}

// signOut also redirects, so its return type for useFormState isn't usually relevant.
export async function signOut(): Promise<{ error?: string } | void> {
  // void because redirect throws
  const supabase = createClient();
  const { error } = await (await supabase).auth.signOut();

  if (error) {
    console.error("Sign out error:", error);
    return { error: "Could not sign out." };
  }
  redirect("/login");
}
</file>

<file path="app/auth/callback/route.ts">
// app/auth/callback/route.ts
import { NextResponse, type NextRequest } from "next/server";
import { createClient } from "@/lib/supabase/server";

export async function GET(request: NextRequest) {
  const requestUrl = new URL(request.url);
  const code = requestUrl.searchParams.get("code");
  const origin = requestUrl.origin;

  if (code) {
    const supabase = createClient();
    const { error } = await (await supabase).auth.exchangeCodeForSession(code);
    if (error) {
      console.error("Error exchanging code for session:", error);
      return NextResponse.redirect(
        `${origin}/login?error=Could not authenticate user`
      );
    }
  } else {
    // This might also be the redirect from email confirmation
    const error_description = requestUrl.searchParams.get("error_description");
    if (error_description) {
      return NextResponse.redirect(
        `${origin}/login?error=${encodeURIComponent(error_description)}`
      );
    }
  }

  // URL to redirect to after sign in process completes
  return NextResponse.redirect(`${origin}/`);
}
</file>

<file path="app/movies/[category]/loading.tsx">
// app/movies/[category]/loading.tsx
import MediaGridSkeleton from "@/components/skeletons/MediaGridSkeleton";

export default function CategoryLoading() {
  return (
    <div className="container mx-auto px-4 py-8">
      {/* The page title is usually handled by the page itself or layout,
          but you can add a placeholder for the grid's own title if needed. */}
      <MediaGridSkeleton itemCount={12} showTitle={true} />
    </div>
  );
}
</file>

<file path="app/movies/detail/[id]/loading.tsx">
// app/movies/detail/[id]/loading.tsx
import MovieDetailSkeleton from "@/components/skeletons/MovieDetailSkeleton";

export default function MovieDetailLoadingPage() {
  return <MovieDetailSkeleton />;
}
</file>

<file path="app/profile/actions.ts">
// app/profile/actions.ts
"use server";

import { createClient } from "@/lib/supabase/server";
import { z } from "zod";
import { revalidatePath } from "next/cache";

export type ProfileFormActionState = {
  error?: string;
  fieldErrors?: { [key: string]: string[] | undefined };
  success?: boolean;
  message?: string;
} | null;

// Schema for password update
const passwordUpdateSchema = z
  .object({
    newPassword: z
      .string()
      .min(8, "New password must be at least 8 characters."),
    confirmPassword: z.string(),
  })
  .refine((data) => data.newPassword === data.confirmPassword, {
    message: "Passwords do not match.",
    path: ["confirmPassword"],
  });

export async function updateUserPassword(
  prevState: ProfileFormActionState,
  formData: FormData
): Promise<ProfileFormActionState> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { error: "User not authenticated." };
  }
  // Ensure this action is only for email provider users
  if (user.app_metadata.provider && user.app_metadata.provider !== "email") {
    return { error: "Password cannot be changed for OAuth users." };
  }

  const validatedFields = passwordUpdateSchema.safeParse({
    newPassword: formData.get("newPassword"),
    confirmPassword: formData.get("confirmPassword"),
  });

  if (!validatedFields.success) {
    return {
      error: "Invalid data.",
      fieldErrors: validatedFields.error.flatten().fieldErrors,
    };
  }

  const { error: updateError } = await supabase.auth.updateUser({
    password: validatedFields.data.newPassword,
  });

  if (updateError) {
    console.error("Password update error:", updateError);
    return { error: updateError.message || "Could not update password." };
  }

  revalidatePath("/profile");
  return { success: true, message: "Password updated successfully." };
}

// Schema for profile update (e.g., full_name)
const profileUpdateSchema = z.object({
  fullName: z
    .string()
    .max(100, "Full name cannot exceed 100 characters.")
    .optional()
    .or(z.literal("")),
  // username: z.string().min(3, "Username must be >= 3 chars").max(50).regex(/^[a-zA-Z0-9_]+$/, "Invalid characters").optional().or(z.literal('')),
});

export async function updateUserProfile(
  prevState: ProfileFormActionState,
  formData: FormData
): Promise<ProfileFormActionState> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { error: "User not authenticated." };
  }

  const fullNameValue = formData.get("fullName") as string | null;
  // const usernameValue = formData.get("username") as string | null;

  const validatedFields = profileUpdateSchema.safeParse({
    fullName: fullNameValue,
    // username: usernameValue,
  });

  if (!validatedFields.success) {
    return {
      error: "Invalid data.",
      fieldErrors: validatedFields.error.flatten().fieldErrors,
    };
  }

  const dataToUpdate: {
    full_name?: string | undefined /*, username?: string | undefined */;
  } = {};

  // Only add to dataToUpdate if the field was actually submitted and validated
  if (validatedFields.data.fullName !== undefined) {
    dataToUpdate.full_name =
      validatedFields.data.fullName === ""
        ? undefined
        : validatedFields.data.fullName; // Store empty as undefined to clear, or the value
  }
  // if (validatedFields.data.username !== undefined) {
  //   dataToUpdate.username = validatedFields.data.username === "" ? undefined : validatedFields.data.username;
  // }

  if (Object.keys(dataToUpdate).length === 0) {
    return { message: "No changes submitted.", success: true }; // No actual update needed
  }

  const { error: updateError } = await supabase.auth.updateUser({
    data: dataToUpdate, // Supabase uses 'data' for user_metadata
  });

  if (updateError) {
    console.error("Profile update error:", updateError);
    return { error: updateError.message || "Could not update profile." };
  }

  revalidatePath("/profile");
  revalidatePath("/", "layout"); // Revalidate layout to update UserButton with new name
  return { success: true, message: "Profile updated successfully." };
}
</file>

<file path="app/profile/page.tsx">
// app/profile/page.tsx
import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import type { Metadata } from "next";
import { UpdatePasswordForm } from "@/components/auth/update-password-form";
import { UpdateProfileForm } from "@/components/auth/update-profile-form";
import {
  Card,
  CardContent,
  /*CardDescription,*/
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
// If you have shadcn-ui Separator:
// import { Separator } from "@/components/ui/separator";

export const metadata: Metadata = {
  title: "My Profile | SceneIt",
  description: "Manage your account settings.",
};

export default async function ProfilePage() {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login?message=Please log in to view your profile.");
  }

  // Check if the user signed up via email/password or OAuth
  // `user.app_metadata.provider` will be 'google', 'github', etc. for OAuth
  // or undefined/null (or sometimes 'email') for email/password.
  const isEmailProvider =
    !user.app_metadata.provider || user.app_metadata.provider === "email";

  return (
    <main className="container mx-auto px-4 py-8 max-w-2xl space-y-8">
      <h1 className="text-3xl sm:text-4xl font-bold">My Profile</h1>

      <Card>
        <CardHeader>
          <CardTitle>Account Information</CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          <div>
            <p className="text-sm font-medium text-muted-foreground">
              Email Address
            </p>
            <p>{user.email}</p>
          </div>
          {user.user_metadata.full_name && (
            <div>
              <p className="text-sm font-medium text-muted-foreground">
                Current Display Name
              </p>
              <p>{user.user_metadata.full_name}</p>
            </div>
          )}
          {/*
           user.user_metadata.username && (
             <div>
                <p className="text-sm font-medium text-muted-foreground">Username</p>
                <p>{user.user_metadata.username}</p>
            </div>
          )
          */}
          <div>
            <p className="text-sm font-medium text-muted-foreground">
              Joined SceneIt
            </p>
            <p>
              {new Date(user.created_at).toLocaleDateString("en-US", {
                year: "numeric",
                month: "long",
                day: "numeric",
              })}
            </p>
          </div>
          {user.app_metadata.provider &&
            user.app_metadata.provider !== "email" && (
              <div>
                <p className="text-sm font-medium text-muted-foreground">
                  Sign-in Method
                </p>
                <p className="capitalize">{user.app_metadata.provider}</p>
              </div>
            )}
        </CardContent>
      </Card>

      <UpdateProfileForm
        currentFullName={user.user_metadata.full_name || ""}
        // currentUsername={user.user_metadata.username || ""}
      />

      {isEmailProvider && (
        <>
          {/* <Separator className="my-6" />  Use if available */}
          <hr className="my-6 border-border" />
          <UpdatePasswordForm />
        </>
      )}

      {/* 
      <hr className="my-6 border-border" />
      <Card className="border-destructive">
        <CardHeader>
            <CardTitle className="text-destructive">Danger Zone</CardTitle>
            <CardDescription>Account deletion is permanent and cannot be undone.</CardDescription>
        </CardHeader>
        <CardContent>
            <Button variant="destructive" disabled>Delete My Account (Coming Soon)</Button>
        </CardContent>
      </Card>
      */}
    </main>
  );
}
</file>

<file path="app/search/loading.tsx">
// app/search/loading.tsx
import MediaGridSkeleton from "@/components/skeletons/MediaGridSkeleton";

export default function SearchLoading() {
  return (
    <div className="container mx-auto px-4 py-8">
      {/* Placeholder for the title "Showing results for..." */}
      <div className="animate-pulse mb-8">
        <div className="h-8 bg-muted rounded w-3/4 sm:w-1/2"></div>
      </div>
      {/* Use the existing MediaGridSkeleton */}
      <MediaGridSkeleton itemCount={12} showTitle={false} />
    </div>
  );
}
</file>

<file path="app/search/page.tsx">
// app/search/page.tsx
import { searchMovies, MediaItem, TMDBResponse } from "@/lib/tmdb";
import { MediaCard } from "@/components/MediaCard";
import Link from "next/link";
import { Button } from "@/components/ui/button";

interface SearchPageProps {
  searchParams: Promise<{
    q?: string;
    page?: string;
  }>;
}

export async function generateMetadata({ searchParams }: SearchPageProps) {
  const resolvedSearchParams = await searchParams;
  const query = resolvedSearchParams.q || "";
  if (query) {
    return {
      title: `Search: "${query}" - SceneIt`,
    };
  }
  return {
    title: "Search - SceneIt",
  };
}

export default async function SearchPage({ searchParams }: SearchPageProps) {
  const resolvedSearchParams = await searchParams;
  const query = resolvedSearchParams.q?.trim() || "";
  const currentPage = parseInt(resolvedSearchParams.page || "1", 10);

  if (!query) {
    return (
      <div className="container mx-auto px-4 py-8 text-center min-h-[50vh] flex flex-col justify-center items-center">
        <h1 className="text-3xl font-semibold mb-4">Search Movies</h1>
        <p className="text-muted-foreground">
          Please enter a search term in the bar above to find movies.
        </p>
      </div>
    );
  }

  const searchResponse: TMDBResponse = await searchMovies(query, currentPage);
  const movies: MediaItem[] = searchResponse.results;

  if (movies.length === 0) {
    return (
      <div className="container mx-auto px-4 py-8 text-center min-h-[50vh] flex flex-col justify-center items-center">
        <h1 className="text-3xl font-semibold mb-4">
          No results found for &quot;{query}&quot;
        </h1>
        <p className="text-muted-foreground">
          Try a different search term or check your spelling.
        </p>
        <Button asChild variant="link" className="mt-6">
          <Link href="/">Back to Home</Link>
        </Button>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8 page-transition">
      <h1 className="text-3xl font-semibold mb-8">
        Showing results for &quot;{query}&quot;
      </h1>

      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 md:gap-6">
        {movies.map((movie) => (
          <MediaCard key={movie.id} item={movie} mediaType="movie" />
        ))}
      </div>

      {/* Pagination */}
      {searchResponse.total_pages > 1 && (
        <div className="flex justify-between items-center mt-12">
          <Button asChild variant="outline" disabled={currentPage <= 1}>
            <Link
              href={`/search?q=${encodeURIComponent(query)}&page=${
                currentPage - 1
              }`}
              scroll={false}
            >
              Previous
            </Link>
          </Button>
          <p className="text-sm text-muted-foreground">
            Page {currentPage} of {searchResponse.total_pages} ({searchResponse.total_results} results)
          </p>
          <Button
            asChild
            variant="outline"
            disabled={currentPage >= searchResponse.total_pages}
          >
            <Link
              href={`/search?q=${encodeURIComponent(query)}&page=${
                currentPage + 1
              }`}
              scroll={false}
            >
              Next
            </Link>
          </Button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/watchlist/actions.ts">
// app/watchlist/actions.ts
"use server";

import { createClient } from "@/lib/supabase/server";
import { revalidatePath } from "next/cache";

export interface WatchlistDbItem {
  id: number; // primary key from DB
  user_id: string;
  movie_id: number;
  media_type: string;
  added_at: string;
}

// Action to add a movie to the watchlist
export async function addToWatchlist(
  movieId: number,
  mediaType: "movie" = "movie"
): Promise<{ success: boolean; error?: string; alreadyExists?: boolean }> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { success: false, error: "User not authenticated." };
  }

  // Check if already in watchlist to prevent duplicate attempts or provide specific feedback
  const { data: existingItem, error: selectError } = await supabase
    .from("user_watchlists")
    .select("id")
    .eq("user_id", user.id)
    .eq("movie_id", movieId)
    .eq("media_type", mediaType)
    .maybeSingle();

  if (selectError) {
    console.error("Error checking watchlist:", selectError);
    return { success: false, error: "Could not check watchlist status." };
  }

  if (existingItem) {
    return { success: true, alreadyExists: true };
  }

  const { error: insertError } = await supabase.from("user_watchlists").insert({
    user_id: user.id,
    movie_id: movieId,
    media_type: mediaType,
  });

  if (insertError) {
    console.error("Error adding to watchlist:", insertError);
    // The unique_user_movie constraint handles race conditions if this check fails
    if (insertError.code === "23505") {
      // unique_violation
      return { success: true, alreadyExists: true };
    }
    return { success: false, error: "Could not add movie to watchlist." };
  }

  revalidatePath("/watchlist");
  revalidatePath(`/movies/detail/${movieId}`); // Revalidate specific movie detail page
  revalidatePath("/", "layout"); // Revalidate layout if watchlist count is shown somewhere
  return { success: true };
}

// Action to remove a movie from the watchlist
export async function removeFromWatchlist(
  movieId: number,
  mediaType: "movie" = "movie"
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { success: false, error: "User not authenticated." };
  }

  const { error } = await supabase
    .from("user_watchlists")
    .delete()
    .eq("user_id", user.id)
    .eq("movie_id", movieId)
    .eq("media_type", mediaType);

  if (error) {
    console.error("Error removing from watchlist:", error);
    return { success: false, error: "Could not remove movie from watchlist." };
  }

  revalidatePath("/watchlist");
  revalidatePath(`/movies/detail/${movieId}`);
  revalidatePath("/", "layout");
  return { success: true };
}

// Action to get all watchlist items for the current user
export async function getWatchlistItems(): Promise<{
  data?: WatchlistDbItem[];
  error?: string;
}> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { error: "User not authenticated." };
  }

  const { data, error } = await supabase
    .from("user_watchlists")
    .select("*")
    .eq("user_id", user.id)
    .order("added_at", { ascending: false });

  if (error) {
    console.error("Error fetching watchlist items:", error);
    return { error: "Could not fetch watchlist." };
  }

  return { data: data as WatchlistDbItem[] };
}

// Action to check if a specific movie is in the user's watchlist
export async function isMovieInWatchlist(
  movieId: number,
  mediaType: "movie" = "movie"
): Promise<boolean> {
  // console.log(`[isMovieInWatchlist ACTION] Checking: movieId=${movieId}, mediaType=${mediaType}`);
  const supabase = await createClient();
  const {
    data: { user }, // This 'data' here refers to the auth.getUser() result, which is fine.
  } = await supabase.auth.getUser();

  if (!user) {
    // console.log(`[isMovieInWatchlist ACTION] No user. Returning false.`);
    return false;
  }
  // console.log(`[isMovieInWatchlist ACTION] User ID: ${user.id}. Querying DB.`);

  // The ESLint error was for the 'data' variable from THIS query:
  const { error, count } = await supabase // Removed 'data' from here
    .from("user_watchlists")
    .select("id", { count: "exact", head: true }) // Efficiently check existence
    .eq("user_id", user.id)
    .eq("movie_id", movieId)
    .eq("media_type", mediaType);

  if (error) {
    console.error(
      "[isMovieInWatchlist ACTION] Error checking watchlist:",
      error
    );
    return false;
  }

  const isIn = (count ?? 0) > 0;
  // console.log(`[isMovieInWatchlist ACTION] Movie in watchlist for user ${user.id}? ${isIn}. Count: ${count}`);
  return isIn;
}
</file>

<file path="app/watchlist/page.tsx">
// app/watchlist/page.tsx
import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import { getWatchlistItems } from "./actions";
import { getMovieDetails, MediaItem } from "@/lib/tmdb";
import { MediaCard } from "@/components/MediaCard"; // Re-using MediaCard
import Link from "next/link";
import { Button } from "@/components/ui/button";
import type { Metadata } from "next";
import MediaGridSkeleton from "@/components/skeletons/MediaGridSkeleton"; // For loading state
import { Suspense } from "react";

export const metadata: Metadata = {
  title: "My Watchlist | SceneIt",
  description: "Movies you've saved to watch later.",
};

async function WatchlistGrid() {
  const { data: watchlistDbItems, error: watchlistError } = await getWatchlistItems();

  if (watchlistError) {
    return <p className="text-red-500 text-center">{watchlistError}</p>;
  }

  if (!watchlistDbItems || watchlistDbItems.length === 0) {
    return (
      <div className="text-center">
        <p className="text-muted-foreground text-lg">Your watchlist is empty.</p>
        <p className="text-muted-foreground mt-2">
          Add movies to your watchlist from their detail pages.
        </p>
        <Button asChild className="mt-6">
          <Link href="/">Browse Movies</Link>
        </Button>
      </div>
    );
  }

  const movieDetailsPromises = watchlistDbItems.map(item =>
    getMovieDetails(item.movie_id.toString()).catch(err => {
      console.error(`Failed to fetch details for movie ID ${item.movie_id}:`, err);
      return null; // Handle individual fetch errors gracefully
    })
  );
  
  const moviesWithDetailsUnfiltered = await Promise.all(movieDetailsPromises);
  const moviesWithDetails = moviesWithDetailsUnfiltered.filter(movie => movie !== null) as MediaItem[];

  if (moviesWithDetails.length === 0 && watchlistDbItems.length > 0) {
     return <p className="text-center text-muted-foreground">Could not load details for movies in your watchlist. Please try again later.</p>;
  }
  
  if (moviesWithDetails.length === 0) { // Should be caught by the earlier check, but as a safeguard
    return <p className="text-center text-muted-foreground text-lg">Your watchlist is empty or movie details could not be loaded.</p>;
  }

  return (
    <div className="grid grid-cols-2 place-items-center sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 sm:gap-6">
      {moviesWithDetails.map((movie) => (
        <div key={movie.id} className="w-full">
          <MediaCard item={movie} mediaType="movie" />
        </div>
      ))}
    </div>
  );
}


export default async function WatchlistPage() {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login?message=Please log in to view your watchlist.");
  }

  return (
    <main className="container mx-auto px-4 py-8 page-transition">
      <div className="flex flex-col sm:flex-row justify-between items-center mb-8 gap-4">
        <h1 className="text-3xl sm:text-4xl font-bold text-center sm:text-left">My Watchlist</h1>
        <Button asChild variant="outline" size="sm">
          <Link href="/">← Browse More Movies</Link>
        </Button>
      </div>
      <Suspense fallback={<MediaGridSkeleton itemCount={6} showTitle={false} />}>
        <WatchlistGrid />
      </Suspense>
    </main>
  );
}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="components/auth/auth-form-wrapper.tsx">
// components/auth/auth-form-wrapper.tsx
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import Link from "next/link";

interface AuthFormWrapperProps {
  children: React.ReactNode;
  title: string;
  description: string;
  footerText: string;
  footerLinkHref: string;
  footerLinkText: string;
}

export function AuthFormWrapper({
  children,
  title,
  description,
  footerText,
  footerLinkHref,
  footerLinkText,
}: AuthFormWrapperProps) {
  return (
    <div className="flex items-center justify-center min-h-[calc(100vh-200px)]">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>{title}</CardTitle>
          <CardDescription>{description}</CardDescription>
        </CardHeader>
        <CardContent>
          {children}
          <p className="mt-4 text-center text-sm text-muted-foreground">
            {footerText}{" "}
            <Link
              href={footerLinkHref}
              className="underline hover:text-primary"
            >
              {footerLinkText}
            </Link>
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="components/auth/login-form.tsx">
// components/auth/login-form.tsx
"use client";

import { useFormStatus } from "react-dom";
import { useActionState } from "react";
// Import FormActionState and the correctly typed actions
import {
  signInWithEmail,
  signInWithGoogle,
  FormActionState,
} from "@/app/auth/actions";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useEffect, useState } from "react";
import { toast } from "sonner";
import { LogIn, Loader2 } from "lucide-react";

function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <Button type="submit" className="w-full" disabled={pending}>
      {pending ? (
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      ) : (
        <LogIn className="mr-2 h-4 w-4" />
      )}
      Sign In
    </Button>
  );
}

export function LoginForm() {
  // Explicitly provide types to useFormState
  const [state, formAction] = useActionState<FormActionState, FormData>(
    signInWithEmail,
    null
  );
  const [googleLoading, setGoogleLoading] = useState(false);

  useEffect(() => {
    // `state` can be null, so use optional chaining
    if (state?.error) {
      toast.error(state.error, {
        description: state.fieldErrors
          ? Object.values(state.fieldErrors).flat().join(", ")
          : undefined,
      });
    }
    // No success toast needed here as signInWithEmail redirects on success
  }, [state]);

  const handleGoogleSignIn = async () => {
    setGoogleLoading(true);
    const result = await signInWithGoogle(); // This action has its own return type
    if (result?.url) {
      window.location.href = result.url;
    } else if (result?.error) {
      toast.error(result.error);
      setGoogleLoading(false);
    }
  };

  return (
    <form action={formAction} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="email">Email</Label>
        <Input
          id="email"
          name="email"
          type="email"
          placeholder="m@example.com"
          required
        />
        {/* `state` can be null */}
        {state?.fieldErrors?.email && (
          <p className="text-xs text-red-500">
            {state.fieldErrors.email.join(", ")}
          </p>
        )}
      </div>
      <div className="space-y-2">
        <Label htmlFor="password">Password</Label>
        <Input id="password" name="password" type="password" required />
        {/* `state` can be null */}
        {state?.fieldErrors?.password && (
          <p className="text-xs text-red-500">
            {state.fieldErrors.password.join(", ")}
          </p>
        )}
      </div>
      <SubmitButton />
      <Button
        type="button"
        variant="outline"
        className="w-full"
        onClick={handleGoogleSignIn}
        disabled={googleLoading}
      >
        {googleLoading ? (
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
        ) : (
          "G"
        )}{" "}
        {/* Replace with Google icon */}
        Sign In with Google
      </Button>
    </form>
  );
}
</file>

<file path="components/auth/signup-form.tsx">
// components/auth/signup-form.tsx
"use client";

import { useFormStatus } from "react-dom";
import { useActionState } from "react";
// Import FormActionState and the correctly typed actions
import {
  signUpWithEmail,
  signInWithGoogle,
  FormActionState,
} from "@/app/auth/actions";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useEffect, useState } from "react";
import { toast } from "sonner";
import { UserPlus, Loader2 } from "lucide-react";

function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <Button type="submit" className="w-full" disabled={pending}>
      {pending ? (
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      ) : (
        <UserPlus className="mr-2 h-4 w-4" />
      )}
      Sign Up
    </Button>
  );
}

export function SignupForm() {
  // Explicitly provide types to useActionState
  const [state, formAction] = useActionState<FormActionState, FormData>(
    signUpWithEmail,
    null
  );
  const [googleLoading, setGoogleLoading] = useState(false);

  useEffect(() => {
    // `state` can be null, so use optional chaining
    if (state?.error) {
      toast.error(state.error, {
        description: state.fieldErrors
          ? Object.values(state.fieldErrors).flat().join(", ")
          : undefined,
      });
    }
    // `state` can be null, check for `success` and `message` before accessing
    if (state?.success && state.message) {
      toast.success(state.message);
    }
  }, [state]);

  const handleGoogleSignIn = async () => {
    setGoogleLoading(true);
    // signInWithGoogle has its own return type, not FormActionState
    const result = await signInWithGoogle();
    if (result?.url) {
      window.location.href = result.url;
    } else if (result?.error) {
      toast.error(result.error);
      setGoogleLoading(false);
    }
  };

  return (
    <form action={formAction} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="email">Email</Label>
        <Input
          id="email"
          name="email"
          type="email"
          placeholder="m@example.com"
          required
        />
        {/* `state` can be null */}
        {state?.fieldErrors?.email && (
          <p className="text-xs text-red-500">
            {state.fieldErrors.email.join(", ")}
          </p>
        )}
      </div>
      <div className="space-y-2">
        <Label htmlFor="password">Password</Label>
        <Input id="password" name="password" type="password" required />
        {/* `state` can be null */}
        {state?.fieldErrors?.password && (
          <p className="text-xs text-red-500">
            {state.fieldErrors.password.join(", ")}
          </p>
        )}
      </div>
      <SubmitButton />
      <Button
        type="button"
        variant="outline"
        className="w-full"
        onClick={handleGoogleSignIn}
        disabled={googleLoading}
      >
        {googleLoading ? (
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
        ) : (
          "G"
        )}{" "}
        {/* Replace with Google icon */}
        Sign Up with Google
      </Button>
    </form>
  );
}
</file>

<file path="components/auth/update-password-form.tsx">
// components/auth/update-password-form.tsx
"use client";

import { useFormStatus } from "react-dom";
import { useActionState } from "react";
import {
  updateUserPassword,
  ProfileFormActionState,
} from "@/app/profile/actions";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useEffect } from "react";
import { toast } from "sonner";
import { Loader2, KeyRound } from "lucide-react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <Button type="submit" disabled={pending} className="w-full sm:w-auto">
      {pending ? (
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      ) : (
        <KeyRound className="mr-2 h-4 w-4" />
      )}
      Update Password
    </Button>
  );
}

export function UpdatePasswordForm() {
  const [state, formAction] = useActionState<ProfileFormActionState, FormData>(
    updateUserPassword,
    null
  );

  useEffect(() => {
    if (state?.error) {
      toast.error(state.error, {
        description: state.fieldErrors
          ? Object.values(state.fieldErrors).flat().join(", ")
          : undefined,
      });
    }
    if (state?.success && state.message) {
      toast.success(state.message);
      // Consider resetting form fields here if needed, though revalidation might handle it.
    }
  }, [state]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Change Password</CardTitle>
        <CardDescription>
          Enter a new password for your account. Make sure it&apos;s strong!
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form action={formAction} className="space-y-6">
          <div className="space-y-2">
            <Label htmlFor="newPassword">New Password</Label>
            <Input
              id="newPassword"
              name="newPassword"
              type="password"
              required
              autoComplete="new-password"
            />
            {state?.fieldErrors?.newPassword && (
              <p className="text-xs text-destructive">
                {state.fieldErrors.newPassword.join(", ")}
              </p>
            )}
          </div>
          <div className="space-y-2">
            <Label htmlFor="confirmPassword">Confirm New Password</Label>
            <Input
              id="confirmPassword"
              name="confirmPassword"
              type="password"
              required
              autoComplete="new-password"
            />
            {state?.fieldErrors?.confirmPassword && (
              <p className="text-xs text-destructive">
                {state.fieldErrors.confirmPassword.join(", ")}
              </p>
            )}
          </div>
          <SubmitButton />
        </form>
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/auth/update-profile-form.tsx">
// components/auth/update-profile-form.tsx
"use client";

import { useFormStatus } from "react-dom";
import { useActionState } from "react";
import {
  updateUserProfile,
  ProfileFormActionState,
} from "@/app/profile/actions";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useEffect, useState } from "react";
import { toast } from "sonner";
import { Loader2, UserCog } from "lucide-react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

interface UpdateProfileFormProps {
  currentFullName: string;
  // currentUsername?: string; // If you add username
}

function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <Button type="submit" disabled={pending} className="w-full sm:w-auto">
      {pending ? (
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      ) : (
        <UserCog className="mr-2 h-4 w-4" />
      )}
      Save Changes
    </Button>
  );
}

export function UpdateProfileForm({ currentFullName }: UpdateProfileFormProps) {
  const [state, formAction] = useActionState<ProfileFormActionState, FormData>(
    updateUserProfile,
    null
  );
  const [fullName, setFullName] = useState(currentFullName);
  // const [username, setUsername] = useState(currentUsername || "");

  useEffect(() => {
    if (state?.error) {
      toast.error(state.error, {
        description: state.fieldErrors
          ? Object.values(state.fieldErrors).flat().join(", ")
          : undefined,
      });
    }
    if (state?.success && state.message) {
      toast.success(state.message);
    }
  }, [state]);

  // Update local state if the prop changes (e.g., after successful server update and re-render)
  useEffect(() => {
    setFullName(currentFullName);
  }, [currentFullName]);
  // useEffect(() => {
  //   setUsername(currentUsername || "");
  // }, [currentUsername]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Personal Information</CardTitle>
        <CardDescription>
          Update your display name. This will be shown publicly.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form action={formAction} className="space-y-6">
          <div className="space-y-2">
            <Label htmlFor="fullName">Full Name</Label>
            <Input
              id="fullName"
              name="fullName"
              type="text"
              placeholder="Your full name (e.g. Jane Doe)"
              value={fullName}
              onChange={(e) => setFullName(e.target.value)}
            />
            {state?.fieldErrors?.fullName && (
              <p className="text-xs text-destructive">
                {state.fieldErrors.fullName.join(", ")}
              </p>
            )}
          </div>
          {/* 
          <div className="space-y-2">
            <Label htmlFor="username">Username (optional)</Label>
            <Input 
              id="username" 
              name="username" 
              type="text" 
              placeholder="A unique username (e.g. jane_doe)" 
              value={username}
              onChange={(e) => setUsername(e.target.value)}
            />
            {state?.fieldErrors?.username && (
              <p className="text-xs text-destructive">{state.fieldErrors.username.join(", ")}</p>
            )}
          </div>
          */}
          <SubmitButton />
        </form>
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/dark-mode-toggle.tsx">
"use client"

import * as React from "react"
import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"

import { Button } from "@/components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"

export function DarkModeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}
</file>

<file path="components/SearchInput.tsx">
// app/components/SearchInput.tsx
"use client";

import { useState, FormEvent, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { Search as SearchIcon } from "lucide-react"; // Renamed to avoid conflict if you have a Search component
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";

export function SearchInput() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [query, setQuery] = useState(searchParams.get("q") || "");

  // Update query in input if URL changes (e.g., back/forward button or direct navigation)
  useEffect(() => {
    setQuery(searchParams.get("q") || "");
  }, [searchParams]);

  const handleSearch = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const trimmedQuery = query.trim();
    if (trimmedQuery) {
      router.push(`/search?q=${encodeURIComponent(trimmedQuery)}`);
    } else {
      // If the query is empty, navigate to the base search page
      // which will prompt the user to enter a term.
      router.push("/search");
    }
  };

  return (
    <form
      onSubmit={handleSearch}
      className="flex w-full items-center space-x-2"
      role="search"
    >
      <Input
        type="search"
        placeholder="Search movies..."
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        className="flex-grow"
        aria-label="Search movies"
      />
      <Button
        type="submit"
        variant="outline"
        size="icon"
        aria-label="Perform search"
      >
        <SearchIcon className="h-5 w-5" />
      </Button>
    </form>
  );
}
</file>

<file path="components/skeletons/MediaGridSkeleton.tsx">
// components/skeletons/MediaGridSkeleton.tsx
const SkeletonCard = () => (
  <div className="animate-pulse space-y-3">
    <div className="bg-gray-300 dark:bg-gray-700 h-60 md:h-72 rounded-md"></div> {/* Poster placeholder */}
    <div className="space-y-2">
      <div className="bg-gray-300 dark:bg-gray-700 h-4 w-3/4 rounded"></div> {/* Title placeholder */}
      <div className="bg-gray-300 dark:bg-gray-700 h-4 w-1/2 rounded"></div> {/* Subtitle/date placeholder */}
    </div>
  </div>
);

export default function MediaGridSkeleton({ itemCount = 6, showTitle = true }) {
  return (
    <div className="py-8">
      {showTitle && (
        <div className="animate-pulse mb-6">
          <div className="bg-gray-300 dark:bg-gray-700 h-7 w-1/3 md:w-1/4 rounded"></div> {/* Section Title placeholder */}
        </div>
      )}
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 md:gap-6">
        {Array.from({ length: itemCount }).map((_, index) => (
          <SkeletonCard key={index} />
        ))}
      </div>
    </div>
  );
}
</file>

<file path="components/theme-provider.tsx">
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}
</file>

<file path="components/ui/aspect-ratio.tsx">
"use client"

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

function AspectRatio({
  ...props
}: React.ComponentProps<typeof AspectRatioPrimitive.Root>) {
  return <AspectRatioPrimitive.Root data-slot="aspect-ratio" {...props} />
}

export { AspectRatio }
</file>

<file path="components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="components/ui/label.tsx">
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";

import { cn } from "@/lib/utils";

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  );
}

export { Label };
</file>

<file path="components/ui/pagination.tsx">
import * as React from "react"
import {
  ChevronLeftIcon,
  ChevronRightIcon,
  MoreHorizontalIcon,
} from "lucide-react"

import { cn } from "@/lib/utils"
import { Button, buttonVariants } from "@/components/ui/button"

function Pagination({ className, ...props }: React.ComponentProps<"nav">) {
  return (
    <nav
      role="navigation"
      aria-label="pagination"
      data-slot="pagination"
      className={cn("mx-auto flex w-full justify-center", className)}
      {...props}
    />
  )
}

function PaginationContent({
  className,
  ...props
}: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="pagination-content"
      className={cn("flex flex-row items-center gap-1", className)}
      {...props}
    />
  )
}

function PaginationItem({ ...props }: React.ComponentProps<"li">) {
  return <li data-slot="pagination-item" {...props} />
}

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<React.ComponentProps<typeof Button>, "size"> &
  React.ComponentProps<"a">

function PaginationLink({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) {
  return (
    <a
      aria-current={isActive ? "page" : undefined}
      data-slot="pagination-link"
      data-active={isActive}
      className={cn(
        buttonVariants({
          variant: isActive ? "outline" : "ghost",
          size,
        }),
        className
      )}
      {...props}
    />
  )
}

function PaginationPrevious({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to previous page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pl-2.5", className)}
      {...props}
    >
      <ChevronLeftIcon />
      <span className="hidden sm:block">Previous</span>
    </PaginationLink>
  )
}

function PaginationNext({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to next page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pr-2.5", className)}
      {...props}
    >
      <span className="hidden sm:block">Next</span>
      <ChevronRightIcon />
    </PaginationLink>
  )
}

function PaginationEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      aria-hidden
      data-slot="pagination-ellipsis"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontalIcon className="size-4" />
      <span className="sr-only">More pages</span>
    </span>
  )
}

export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
}
</file>

<file path="components/ui/sonner.tsx">
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="components/watchlist-button.tsx">
// components/watchlist-button.tsx
"use client";

import { useState, useEffect, useTransition, Suspense } from "react";
import { Button } from "@/components/ui/button";
import {
  addToWatchlist,
  removeFromWatchlist,
  isMovieInWatchlist, // Server action for client-side fetch
} from "@/app/watchlist/actions";
import { toast } from "sonner";
import { Heart, CheckCircle, Loader2 } from "lucide-react";
import type { User } from "@supabase/supabase-js";
import { useRouter } from "next/navigation";

interface WatchlistButtonProps {
  movieId: number;
  mediaType?: "movie";
  user: User | null;
  initialIsInWatchlist?: boolean; // This prop will now be undefined when called from MoviePage
  className?: string;
  variant?:
    | "default"
    | "outline"
    | "ghost"
    | "link"
    | "secondary"
    | "destructive"
    | null
    | undefined;
  size?: "default" | "sm" | "lg" | "icon" | null | undefined;
}

function WatchlistButtonContent({
  movieId,
  mediaType = "movie",
  user,
  initialIsInWatchlist,
  className,
  variant = "outline",
  size = "default",
}: WatchlistButtonProps) {
  // If initialIsInWatchlist is provided (e.g. from a page that CAN pre-fetch), use it. Otherwise, default to false.
  const [isInWatchlist, setIsInWatchlist] = useState(
    initialIsInWatchlist ?? false
  );

  // isLoadingClientCheck is true if the client needs to make an explicit check for the watchlist status
  // This happens if initialIsInWatchlist was NOT provided AND a user is logged in.
  const [isLoadingClientCheck, setIsLoadingClientCheck] = useState(
    initialIsInWatchlist === undefined && !!user
  );

  const [isPendingAction, startTransition] = useTransition();
  const router = useRouter();

  useEffect(() => {
    // This effect handles the client-side fetch if needed
    if (user) {
      // If initialIsInWatchlist was NOT provided (is undefined), the server didn't/couldn't determine it.
      // The client then fetches this status.
      if (initialIsInWatchlist === undefined) {
        // console.log(`[WatchlistButton] movieId: ${movieId}, initialIsInWatchlist is undefined. User exists. Fetching client-side.`);
        setIsLoadingClientCheck(true); // Ensure loading state is active
        isMovieInWatchlist(movieId, mediaType)
          .then((fetchedStatus) => {
            // console.log(`[WatchlistButton] movieId: ${movieId}, Client fetch result: ${fetchedStatus}`);
            setIsInWatchlist(fetchedStatus);
          })
          .catch((err) => {
            console.error(
              `[WatchlistButton] movieId: ${movieId}, Failed to check watchlist status on mount (client fetch):`,
              err
            );
            // Optionally set isInWatchlist to false or show an error state on the button itself
          })
          .finally(() => setIsLoadingClientCheck(false));
      } else {
        // Server provided initialIsInWatchlist (true or false), so use it.
        // This also handles cases where the prop might change due to parent re-render.
        // console.log(`[WatchlistButton] movieId: ${movieId}, initialIsInWatchlist provided: ${initialIsInWatchlist}. Using server value.`);
        setIsInWatchlist(initialIsInWatchlist);
        setIsLoadingClientCheck(false); // Not loading if server provided data
      }
    } else {
      // No user, so not in watchlist and not loading a client check.
      // console.log(`[WatchlistButton] movieId: ${movieId}, No user. Setting isInWatchlist to false.`);
      setIsInWatchlist(false);
      setIsLoadingClientCheck(false);
    }
  }, [movieId, mediaType, user, initialIsInWatchlist]); // Dependencies are correct

  const handleToggleWatchlist = () => {
    if (!user) {
      toast.error("Please log in to manage your watchlist.", {
        action: {
          label: "Login",
          onClick: () => router.push("/login"),
        },
      });
      return;
    }

    startTransition(async () => {
      const previousState = isInWatchlist;
      setIsInWatchlist(!previousState); // Optimistic update

      try {
        if (previousState) {
          // Was in watchlist, try to remove
          const result = await removeFromWatchlist(movieId, mediaType);
          if (!result.success)
            throw new Error(result.error || "Failed to remove.");
          toast.success("Removed from watchlist.");
        } else {
          // Was not in watchlist, try to add
          const result = await addToWatchlist(movieId, mediaType);
          if (!result.success)
            throw new Error(result.error || "Failed to add.");
          if (result.alreadyExists) {
            toast.info("Already in your watchlist.");
            setIsInWatchlist(true); // Correct state if server says it's already there
          } else {
            toast.success("Added to watchlist!");
          }
        }
      } catch (e: unknown) {
        let errorMessage = "An error occurred.";
        if (e instanceof Error) {
          errorMessage = e.message;
        }
        toast.error(errorMessage);
        setIsInWatchlist(previousState); // Revert on error
      }
    });
  };

  // Show a loading state for the button itself if the client is fetching its initial status
  if (isLoadingClientCheck) {
    return (
      <Button variant={variant} size={size} className={className} disabled>
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
        Loading Watchlist...
      </Button>
    );
  }

  return (
    <Button
      onClick={handleToggleWatchlist}
      disabled={isPendingAction} // Disable only during add/remove action, not initial client check
      variant={isInWatchlist ? "secondary" : variant}
      size={size}
      className={className}
      aria-pressed={isInWatchlist}
      aria-label={isInWatchlist ? "Remove from watchlist" : "Add to watchlist"}
    >
      {isPendingAction ? (
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      ) : isInWatchlist ? (
        <CheckCircle className="mr-2 h-4 w-4 text-primary" />
      ) : (
        <Heart className="mr-2 h-4 w-4" />
      )}
      {isPendingAction
        ? "Updating..."
        : isInWatchlist
        ? "In Watchlist"
        : "Add to Watchlist"}
    </Button>
  );
}

// The Suspense wrapper around WatchlistButtonContent might not be strictly needed
// if isMovieInWatchlist (server action) doesn't use hooks like useSearchParams internally.
// However, keeping it provides a boundary if future changes introduce such dependencies.
export function WatchlistButton(props: WatchlistButtonProps) {
  return (
    <Suspense
      fallback={
        <Button
          variant={props.variant || "outline"}
          size={props.size || "default"}
          className={props.className}
          disabled
        >
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          Loading...
        </Button>
      }
    >
      <WatchlistButtonContent {...props} />
    </Suspense>
  );
}
</file>

<file path="docker-compose.yml">
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        TMDB_API_KEY: ${TMDB_API_KEY}
    ports:
      - "3000:3000"
    environment:
      NEXT_PUBLIC_TMDB_IMAGE_BASE_URL: ${NEXT_PUBLIC_TMDB_IMAGE_BASE_URL}
      NEXT_PUBLIC_SUPABASE_URL: ${NEXT_PUBLIC_SUPABASE_URL}
      NEXT_PUBLIC_SUPABASE_ANON_KEY: ${NEXT_PUBLIC_SUPABASE_ANON_KEY}
    env_file:
      - .env
</file>

<file path="Dockerfile">
# syntax=docker.io/docker/dockerfile:1

FROM node:22.16.0-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* .npmrc* ./

# Install dependencies
RUN \
  if [ -f yarn.lock ]; then yarn --frozen-lockfile; \
  elif [ -f package-lock.json ]; then npm ci; \
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm i --frozen-lockfile; \
  else echo "Lockfile not found." && exit 1; \
  fi

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app

# Set build-time environment variable
ARG TMDB_API_KEY
ENV TMDB_API_KEY=$TMDB_API_KEY

COPY --from=deps /app/node_modules ./node_modules
COPY . .

RUN \
  if [ -f yarn.lock ]; then yarn run build; \
  elif [ -f package-lock.json ]; then npm run build; \
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm run build; \
  else echo "Lockfile not found." && exit 1; \
  fi

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production

# Runtime env vars
ENV NEXT_PUBLIC_TMDB_IMAGE_BASE_URL=""
ENV NEXT_PUBLIC_SUPABASE_URL=""
ENV NEXT_PUBLIC_SUPABASE_ANON_KEY=""

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000
ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

CMD ["node", "server.js"]
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="lib/supabase/client.ts">
// lib/supabase/client.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
</file>

<file path="lib/supabase/middleware.ts">
// lib/supabase/middleware.ts
import { createServerClient, type CookieOptions } from "@supabase/ssr";
import { type NextRequest, NextResponse } from "next/server";

export async function updateSession(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value,
            ...options,
          });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({
            name,
            value,
            ...options,
          });
        },
        remove(name: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value: "",
            ...options,
          });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({
            name,
            value: "",
            ...options,
          });
        },
      },
    }
  );

  // Refresh session if expired - important for Server Components
  // https://supabase.com/docs/guides/auth/server-side/nextjs
  await supabase.auth.getUser();

  return response;
}
</file>

<file path="lib/supabase/server.ts">
// lib/supabase/server.ts
import { createServerClient, type CookieOptions as SupabaseCookieOptions } from "@supabase/ssr";
import { cookies } from "next/headers";
import type { SerializeOptions } from 'cookie'; // Corrected import

export async function createClient() {
  const cookieStore = await cookies();

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supabaseUrl) {
    throw new Error(
      "NEXT_PUBLIC_SUPABASE_URL is not defined in environment variables."
    );
  }
  if (!supabaseAnonKey) {
    throw new Error(
      "NEXT_PUBLIC_SUPABASE_ANON_KEY is not defined in environment variables."
    );
  }

  return createServerClient(supabaseUrl, supabaseAnonKey, {
    cookies: {
      get(name: string) {
        return cookieStore.get(name)?.value;
      },
      set(name: string, value: string, options: SupabaseCookieOptions) {
        try {
          // The object passed to cookieStore.set needs to match its expected signature.
          // SupabaseCookieOptions is Partial<SerializeOptions>.
          // The actual set method on cookieStore might have its own expectations.
          // We cast the options part to ensure compatibility.
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (cookieStore as any).set(name, value, options as SerializeOptions);
        } catch {
          // The `set` method was called from a Server Component
        }
      },
      remove(name: string, options: SupabaseCookieOptions) {
        try {
          // For removal, typically you'd set an expired cookie or just remove.
          // Here, following Supabase's pattern of using set with empty value.
          // The options for removal usually include path and domain, and expires: new Date(0)
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (cookieStore as any).set(name, "", { ...options, maxAge: 0 } as SerializeOptions);
        } catch {
          // Similar to set
        }
      },
    },
  });
}
</file>

<file path="lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="middleware.ts">
// middleware.ts
import { type NextRequest } from "next/server";
import { updateSession } from "@/lib/supabase/middleware";

export async function middleware(request: NextRequest) {
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
</file>

<file path="open-next.config.ts">
import { defineCloudflareConfig } from "@opennextjs/cloudflare";

export default defineCloudflareConfig();
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="public/Alt_Short_Blue.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 273.42 35.52"><defs><style>.cls-1{fill:url(#linear-gradient);}</style><linearGradient id="linear-gradient" y1="17.76" x2="273.42" y2="17.76" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#90cea1"/><stop offset="0.56" stop-color="#3cbec9"/><stop offset="1" stop-color="#00b3e5"/></linearGradient></defs><title>Asset 3</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><path class="cls-1" d="M191.85,35.37h63.9A17.67,17.67,0,0,0,273.42,17.7h0A17.67,17.67,0,0,0,255.75,0h-63.9A17.67,17.67,0,0,0,174.18,17.7h0A17.67,17.67,0,0,0,191.85,35.37ZM10.1,35.42h7.8V6.92H28V0H0v6.9H10.1Zm28.1,0H46V8.25h.1L55.05,35.4h6L70.3,8.25h.1V35.4h7.8V0H66.45l-8.2,23.1h-.1L50,0H38.2ZM89.14.12h11.7a33.56,33.56,0,0,1,8.08,1,18.52,18.52,0,0,1,6.67,3.08,15.09,15.09,0,0,1,4.53,5.52,18.5,18.5,0,0,1,1.67,8.25,16.91,16.91,0,0,1-1.62,7.58,16.3,16.3,0,0,1-4.38,5.5,19.24,19.24,0,0,1-6.35,3.37,24.53,24.53,0,0,1-7.55,1.15H89.14Zm7.8,28.2h4a21.66,21.66,0,0,0,5-.55A10.58,10.58,0,0,0,110,26a8.73,8.73,0,0,0,2.68-3.35,11.9,11.9,0,0,0,1-5.08,9.87,9.87,0,0,0-1-4.52,9.17,9.17,0,0,0-2.63-3.18A11.61,11.61,0,0,0,106.22,8a17.06,17.06,0,0,0-4.68-.63h-4.6ZM133.09.12h13.2a32.87,32.87,0,0,1,4.63.33,12.66,12.66,0,0,1,4.17,1.3,7.94,7.94,0,0,1,3,2.72,8.34,8.34,0,0,1,1.15,4.65,7.48,7.48,0,0,1-1.67,5,9.13,9.13,0,0,1-4.43,2.82V17a10.28,10.28,0,0,1,3.18,1,8.51,8.51,0,0,1,2.45,1.85,7.79,7.79,0,0,1,1.57,2.62,9.16,9.16,0,0,1,.55,3.2,8.52,8.52,0,0,1-1.2,4.68,9.32,9.32,0,0,1-3.1,3A13.38,13.38,0,0,1,152.32,35a22.5,22.5,0,0,1-4.73.5h-14.5Zm7.8,14.15h5.65a7.65,7.65,0,0,0,1.78-.2,4.78,4.78,0,0,0,1.57-.65,3.43,3.43,0,0,0,1.13-1.2,3.63,3.63,0,0,0,.42-1.8A3.3,3.3,0,0,0,151,8.6a3.42,3.42,0,0,0-1.23-1.13A6.07,6.07,0,0,0,148,6.9a9.9,9.9,0,0,0-1.85-.18h-5.3Zm0,14.65h7a8.27,8.27,0,0,0,1.83-.2,4.67,4.67,0,0,0,1.67-.7,3.93,3.93,0,0,0,1.23-1.3,3.8,3.8,0,0,0,.47-1.95,3.16,3.16,0,0,0-.62-2,4,4,0,0,0-1.58-1.18,8.23,8.23,0,0,0-2-.55,15.12,15.12,0,0,0-2.05-.15h-5.9Z"/></g></g></svg>
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="app/login/page.tsx">
// app/login/page.tsx
import { LoginForm } from "@/components/auth/login-form";
import { AuthFormWrapper } from "@/components/auth/auth-form-wrapper";
import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import { Suspense } from "react";
import { SearchParamErrorDisplay } from "@/components/auth/search-param-error-display";

export default async function LoginPage({
  searchParams,
}: {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}) {
  const resolvedSearchParams = await searchParams;
  
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (user) {
    redirect("/"); // If already logged in, redirect to home
  }

  return (
    <AuthFormWrapper
      title="Welcome Back!"
      description="Sign in to continue to SceneIt."
      footerText="Don't have an account?"
      footerLinkHref="/signup"
      footerLinkText="Sign Up"
    >
      <Suspense fallback={<div>Loading...</div>}>
        <SearchParamErrorDisplay searchParams={resolvedSearchParams} />
      </Suspense>
      <LoginForm />
    </AuthFormWrapper>
  );
}
</file>

<file path="app/signup/page.tsx">
// app/signup/page.tsx
import { SignupForm } from "@/components/auth/signup-form";
import { AuthFormWrapper } from "@/components/auth/auth-form-wrapper";
import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import { Suspense } from "react";
import { SearchParamErrorDisplay } from "@/components/auth/search-param-error-display";

export default async function SignupPage({
  searchParams,
}: {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}) {
  const resolvedSearchParams = await searchParams;
  
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (user) {
    redirect("/"); // If already logged in, redirect to home
  }

  return (
    <AuthFormWrapper
      title="Create an Account"
      description="Join SceneIt to track your favorite movies."
      footerText="Already have an account?"
      footerLinkHref="/login"
      footerLinkText="Sign In"
    >
      <Suspense fallback={<div>Loading...</div>}>
        <SearchParamErrorDisplay searchParams={resolvedSearchParams} />
      </Suspense>
      <SignupForm />
    </AuthFormWrapper>
  );
}
</file>

<file path="components/auth/search-param-error-display.tsx">
// components/auth/search-param-error-display.tsx
"use client";

import { useEffect } from "react";
import { toast } from "sonner";

interface SearchParamErrorDisplayProps {
  searchParams?: { [key: string]: string | string[] | undefined };
}

export function SearchParamErrorDisplay({ searchParams }: SearchParamErrorDisplayProps) {
  useEffect(() => {
    const error = searchParams?.error;
    if (error && typeof error === "string") {
      toast.error(decodeURIComponent(error));
    }
  }, [searchParams]);

  return null; // This component does not render anything itself
}
</file>

<file path="components/auth/user-button.tsx">
// components/auth/user-button.tsx
"use client";

import type { User } from "@supabase/supabase-js";
import Link from "next/link";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { signOut } from "@/app/auth/actions";
import { LogOut, LogIn, UserPlus, UserCircle, ListVideo } from "lucide-react"; // Added UserCircle, ListVideo
import { toast } from "sonner";

interface UserButtonProps {
  user: User | null;
}

export function UserButton({ user }: UserButtonProps) {
  const handleSignOut = async () => {
    const result = await signOut();
    if (result?.error) {
      toast.error(result.error);
    }
    // Redirect is handled by the server action
  };

  if (!user) {
    return (
      <div className="flex items-center gap-2">
        <Button asChild variant="outline" size="sm">
          <Link href="/login">
            <LogIn className="mr-2 h-4 w-4" />
            Login
          </Link>
        </Button>
        <Button asChild size="sm">
          <Link href="/signup">
            <UserPlus className="mr-2 h-4 w-4" />
            Sign Up
          </Link>
        </Button>
      </div>
    );
  }

  const userEmail = user.email || "User";
  const fallbackLetter = (user.user_metadata?.full_name || userEmail)
    .charAt(0)
    .toUpperCase();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" className="relative h-8 w-8 rounded-full">
          <Avatar className="h-8 w-8">
            <AvatarImage
              src={user.user_metadata?.avatar_url}
              alt={user.user_metadata?.full_name || userEmail}
            />
            <AvatarFallback>{fallbackLetter}</AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56" align="end" forceMount>
        <DropdownMenuLabel className="font-normal">
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium leading-none">
              {user.user_metadata?.full_name || userEmail}
            </p>
            {user.user_metadata?.full_name &&
              user.email && ( // Show email only if full_name is also present
                <p className="text-xs leading-none text-muted-foreground">
                  {userEmail}
                </p>
              )}
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem asChild>
          <Link href="/profile" className="cursor-pointer">
            <UserCircle className="mr-2 h-4 w-4" />
            <span>Profile</span>
          </Link>
        </DropdownMenuItem>
        <DropdownMenuItem asChild>
          <Link href="/watchlist" className="cursor-pointer">
            <ListVideo className="mr-2 h-4 w-4" />
            <span>My Watchlist</span>
          </Link>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem onClick={handleSignOut} className="cursor-pointer">
          <LogOut className="mr-2 h-4 w-4" />
          <span>Log out</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="components/footer.tsx">
import Image from "next/image";
import Link from "next/link";

export function Footer() {
  return (
    <footer className="w-full border-t bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container mx-auto px-4 py-8">
        <div className="flex flex-col items-center justify-center gap-4">
          <div className="flex items-center gap-2">
            <span className="text-sm text-muted-foreground">
              Movie Data Provided By
            </span>
            <Link
              href="https://www.themoviedb.org/"
              target="_blank"
              rel="noopener noreferrer"
              className="transition-opacity hover:opacity-80"
            >
              <Image
                src="/Alt_Short_Blue.svg"
                alt="TMDB Logo"
                width={100}
                height={16}
                className="h-auto dark:brightness-200"
              />
            </Link>
          </div>
        </div>
      </div>
    </footer>
  );
}
</file>

<file path="wrangler.toml">
main = ".open-next/worker.js"
  name = "sceneit"
  compatibility_date = "2025-03-25"
  compatibility_flags = ["nodejs_compat"]
  [assets]
  directory = ".open-next/assets"
  binding = "ASSETS"
  [observability.logs]
  enabled = true
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
.env

.open-next
</file>

<file path="app/movies/[category]/page.tsx">
// app/movies/[category]/page.tsx

import React from "react";
import {
  getPopularMovies,
  getTopRatedMovies,
  getUpcomingMovies,
  getNowPlayingMovies,
  TMDBResponse,
} from "@/lib/tmdb";
import { MediaCard } from "@/components/MediaCard";
import {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
} from "@/components/ui/pagination";
import { notFound } from "next/navigation";
import type { Metadata } from "next";

type CategorySlug = "now-playing" | "popular" | "top-rated" | "upcoming";

interface CategoryConfig {
  fetchFunction: (page: number) => Promise<TMDBResponse>;
  title: string;
  mediaType: "movie";
}

const categoryConfigurations: Record<CategorySlug, CategoryConfig> = {
  "now-playing": {
    fetchFunction: getNowPlayingMovies,
    title: "Now Playing Movies",
    mediaType: "movie",
  },
  popular: {
    fetchFunction: getPopularMovies,
    title: "Popular Movies",
    mediaType: "movie",
  },
  "top-rated": {
    fetchFunction: getTopRatedMovies,
    title: "Top Rated Movies",
    mediaType: "movie",
  },
  upcoming: {
    fetchFunction: getUpcomingMovies,
    title: "Upcoming Movies",
    mediaType: "movie",
  },
};

export async function generateMetadata({
  params,
}: {
  params: Promise<{ category: string }>;
}): Promise<Metadata> {
  const resolvedParams = await params;
  const categoryParam = resolvedParams.category;

  if (!categoryConfigurations[categoryParam as CategorySlug]) {
    return { title: "Movies | SceneIt", description: "Browse movies." };
  }

  const { title } = categoryConfigurations[categoryParam as CategorySlug];
  return {
    title: `${title} | SceneIt`,
    description: `Browse all ${title.toLowerCase()}.`,
  };
}

export default async function MovieCategoryPage({
  params,
  searchParams,
}: {
  params: Promise<{ category: string }>;
  searchParams?: Promise<{ [key: string]: string | string[] | undefined }>;
}) {
  const resolvedParams = await params;
  const resolvedSearchParams = searchParams ? await searchParams : undefined;

  const categoryParam = resolvedParams.category;

  if (
    !categoryParam ||
    !Object.keys(categoryConfigurations).includes(categoryParam)
  ) {
    notFound();
  }

  const categorySlug = categoryParam as CategorySlug;
  const config = categoryConfigurations[categorySlug];
  if (!config) notFound();

  const pageQueryParam = resolvedSearchParams?.page;
  let currentPage = 1;
  if (pageQueryParam) {
    const parsedPage = parseInt(
      Array.isArray(pageQueryParam) ? pageQueryParam[0] : pageQueryParam,
      10
    );
    if (!isNaN(parsedPage) && parsedPage > 0) {
      currentPage = parsedPage;
    } else {
      notFound();
    }
  }

  const data = await config.fetchFunction(currentPage);
  const movies = data?.results || [];
  const totalPages = Math.min(data?.total_pages || 1, 500);

  if (currentPage > totalPages && totalPages > 0) {
    notFound();
  }

  const renderPaginationItems = () => {
    const pageNumbers = [];
    const ellipsis = (
      <PaginationItem key="ellipsis">
        <PaginationEllipsis />
      </PaginationItem>
    );
    const pagesToShowAroundCurrent = 1;

    let startPage = Math.max(2, currentPage - pagesToShowAroundCurrent);
    let endPage = Math.min(
      totalPages - 1,
      currentPage + pagesToShowAroundCurrent
    );

    const displayedRangeLength = endPage - startPage + 1;
    const requiredDynamicPages = 2 * pagesToShowAroundCurrent + 1;

    if (displayedRangeLength < requiredDynamicPages && totalPages > 1) {
      if (currentPage < 1 + requiredDynamicPages - 1) {
        endPage = Math.min(
          totalPages - 1,
          startPage + requiredDynamicPages - displayedRangeLength
        );
      } else if (currentPage > totalPages - (requiredDynamicPages - 1)) {
        startPage = Math.max(
          2,
          endPage - requiredDynamicPages + displayedRangeLength
        );
      }
    }

    if (startPage > endPage && totalPages <= 1 + requiredDynamicPages) {
      startPage = 2;
      endPage = totalPages - 1;
    }

    pageNumbers.push(
      <PaginationItem key={1}>
        <PaginationLink
          href={`/movies/${categorySlug}?page=1`}
          isActive={1 === currentPage}
        >
          1
        </PaginationLink>
      </PaginationItem>
    );

    if (startPage > 2)
      pageNumbers.push(React.cloneElement(ellipsis, { key: "start-ellipsis" }));

    for (let i = startPage; i <= endPage; i++) {
      pageNumbers.push(
        <PaginationItem key={i}>
          <PaginationLink
            href={`/movies/${categorySlug}?page=${i}`}
            isActive={i === currentPage}
          >
            {i}
          </PaginationLink>
        </PaginationItem>
      );
    }

    if (endPage < totalPages - 1)
      pageNumbers.push(React.cloneElement(ellipsis, { key: "end-ellipsis" }));

    if (totalPages > 1) {
      pageNumbers.push(
        <PaginationItem key={totalPages}>
          <PaginationLink
            href={`/movies/${categorySlug}?page=${totalPages}`}
            isActive={totalPages === currentPage}
          >
            {totalPages}
          </PaginationLink>
        </PaginationItem>
      );
    }

    return pageNumbers;
  };

  return (
    <main className="container mx-auto px-4 py-8">
      <div className="flex flex-col sm:flex-row justify-between items-center mb-8 gap-4">
        <h1 className="text-3xl sm:text-4xl font-bold text-center sm:text-left">
          {config.title}
        </h1>
        <PaginationLink href="/" size="sm" className="text-sm">
          ← Back to Home
        </PaginationLink>
      </div>

      {movies.length > 0 ? (
        <div className="grid grid-cols-2 place-items-center sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 sm:gap-6">
          {movies.map((movie) => (
            <MediaCard
              key={movie.id}
              item={movie}
              mediaType={config.mediaType}
            />
          ))}
        </div>
      ) : (
        <p className="text-center text-muted-foreground text-lg py-10">
          {currentPage > 1 && totalPages > 0
            ? `No movies found on page ${currentPage} for this category.`
            : "No movies found in this category at the moment."}
        </p>
      )}

      {totalPages > 1 && movies.length > 0 && (
        <div className="mt-12 flex justify-center">
          <Pagination>
            <PaginationContent>
              {currentPage > 1 && (
                <PaginationItem>
                  <PaginationPrevious
                    href={`/movies/${categorySlug}?page=${currentPage - 1}`}
                  />
                </PaginationItem>
              )}
              {renderPaginationItems()}
              {currentPage < totalPages && (
                <PaginationItem>
                  <PaginationNext
                    href={`/movies/${categorySlug}?page=${currentPage + 1}`}
                  />
                </PaginationItem>
              )}
            </PaginationContent>
          </Pagination>
        </div>
      )}
    </main>
  );
}
</file>

<file path="components/MediaGrid.tsx">
// components/MediaGrid.tsx
"use client";

import { MediaCard } from "./MediaCard";
import { MediaItem } from "@/lib/tmdb";
import { useRef, useState, useEffect, useCallback } from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import Link from "next/link"; // Import Next.js Link

interface MediaGridProps {
  items: MediaItem[];
  mediaType: "movie" | "tv";
  title: string;
  moreLinkHref?: string; // New optional prop for "View More" link
}

export function MediaGrid({
  items,
  mediaType,
  title,
  moreLinkHref,
}: MediaGridProps) {
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const [canScrollLeft, setCanScrollLeft] = useState(false);
  const [canScrollRight, setCanScrollRight] = useState(false);

  const checkForScrollability = useCallback(() => {
    const el = scrollContainerRef.current;
    if (el) {
      const hasOverflow = el.scrollWidth > el.clientWidth;
      setCanScrollLeft(el.scrollLeft > 0);
      setCanScrollRight(
        hasOverflow && el.scrollLeft < el.scrollWidth - el.clientWidth - 1
      );
    }
  }, []);

  useEffect(() => {
    const el = scrollContainerRef.current;
    if (el) {
      checkForScrollability();
      el.addEventListener("scroll", checkForScrollability, { passive: true });
      const resizeObserver = new ResizeObserver(checkForScrollability);
      resizeObserver.observe(el);

      return () => {
        el.removeEventListener("scroll", checkForScrollability);
        resizeObserver.unobserve(el);
      };
    }
  }, [items, checkForScrollability]);

  if (!items || items.length === 0) {
    return (
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-2xl font-semibold">{title}</h2>
        {/* This is where "View More" should appear */}
        {moreLinkHref && (
          <Link
            href={moreLinkHref}
            className="text-sm text-primary hover:underline whitespace-nowrap ml-4"
            prefetch={false}
          >
            View More
          </Link>
        )}
      </div>
    );
  }

  const scroll = (direction: "left" | "right") => {
    if (scrollContainerRef.current) {
      const { current } = scrollContainerRef;
      const scrollAmount = current.clientWidth * 0.75;
      current.scrollBy({
        left: direction === "left" ? -scrollAmount : scrollAmount,
        behavior: "smooth",
      });
    }
  };

  // Only show arrows if there are enough items to potentially scroll
  // Adjust this number based on average card width and typical container sizes
  const averageCardWidth = 176; // Corresponds to md:w-44 in MediaCard
  const containerWidth = scrollContainerRef.current?.clientWidth || 0;
  const showArrows =
    items.length * averageCardWidth > containerWidth && items.length > 1;

  return (
    <section className="py-6 relative group">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-2xl font-semibold">{title}</h2>
        {moreLinkHref && (
          <Link
            href={moreLinkHref}
            className="text-sm text-primary hover:underline whitespace-nowrap ml-4"
            prefetch={false}
          >
            View More
          </Link>
        )}
      </div>

      {/* Scroll Left Arrow */}
      {showArrows && (
        <Button
          variant="outline"
          size="icon"
          className={cn(
            "absolute left-0 top-1/2 transform -translate-y-1/2 z-10 p-2 rounded-full shadow-md",
            "opacity-0 group-hover:opacity-100 transition-opacity duration-300 focus:opacity-100",
            "-ml-2 sm:-ml-4",
            !canScrollLeft && "opacity-0 pointer-events-none"
          )}
          onClick={() => scroll("left")}
          disabled={!canScrollLeft}
          aria-label="Scroll left"
        >
          <ChevronLeft className="h-5 w-5" />
        </Button>
      )}

      <div
        ref={scrollContainerRef}
        className="flex overflow-x-auto space-x-3 sm:space-x-4 pb-4 no-scrollbar"
      >
        {items.map((item) => (
          <MediaCard key={item.id} item={item} mediaType={mediaType} />
        ))}
      </div>

      {/* Scroll Right Arrow */}
      {showArrows && (
        <Button
          variant="outline"
          size="icon"
          className={cn(
            "absolute right-0 top-1/2 transform -translate-y-1/2 z-10 p-2 rounded-full shadow-md",
            "opacity-0 group-hover:opacity-100 transition-opacity duration-300 focus:opacity-100",
            "-mr-2 sm:-mr-4",
            !canScrollRight && "opacity-0 pointer-events-none"
          )}
          onClick={() => scroll("right")}
          disabled={!canScrollRight}
          aria-label="Scroll right"
        >
          <ChevronRight className="h-5 w-5" />
        </Button>
      )}
    </section>
  );
}
</file>

<file path="components/skeletons/MovieDetailSkeleton.tsx">
// components/skeletons/MovieDetailSkeleton.tsx
export default function MovieDetailSkeleton() {
  return (
    <div className="container mx-auto px-4 py-8 animate-pulse">
      <div className="flex flex-col gap-8">
        {/* Back Button Placeholder */}
        <div>
          <div className="bg-muted h-8 w-32 rounded-md"></div>
        </div>

        {/* Movie Header */}
        <div className="flex flex-col md:flex-row gap-8">
          {/* Poster Placeholder */}
          <div className="w-full md:w-1/3 lg:w-1/4 flex-shrink-0">
            <div className="bg-muted aspect-[2/3] rounded-lg"></div>
          </div>

          {/* Movie Info Placeholder */}
          <div className="flex-1 space-y-6">
            {/* Title Placeholder */}
            <div className="bg-muted h-10 w-3/4 rounded"></div>
            {/* Tagline Placeholder */}
            <div className="bg-muted h-6 w-1/2 rounded"></div>

            {/* Combined Badges and Watchlist Button Placeholder */}
            <div className="flex flex-col sm:flex-row sm:items-center gap-x-6 gap-y-6 mb-6">
              {/* Badges Placeholder Group */}
              <div className="flex flex-wrap gap-3">
                <div className="bg-muted h-7 w-28 rounded-full"></div>
                <div className="bg-muted h-7 w-24 rounded-full"></div>
                <div className="bg-muted h-7 w-20 rounded-full"></div>
                <div className="bg-muted h-7 w-24 rounded-full"></div>
              </div>
              {/* Watchlist Button Placeholder Wrapper */}
              <div className="w-full sm:w-auto sm:ml-auto">
                <div className="bg-muted h-12 w-full sm:w-48 rounded-md"></div>
              </div>
            </div>

            {/* Genres Placeholder */}
            <div className="space-y-2">
              <div className="bg-muted h-6 w-1/4 rounded"></div>{" "}
              {/* Genres Title */}
              <div className="flex flex-wrap gap-2">
                <div className="bg-muted h-6 w-20 rounded-full"></div>
                <div className="bg-muted h-6 w-24 rounded-full"></div>
                <div className="bg-muted h-6 w-16 rounded-full"></div>
              </div>
            </div>

            {/* Overview Placeholder */}
            <div className="space-y-2">
              <div className="bg-muted h-6 w-1/5 rounded"></div>{" "}
              {/* Overview Title */}
              <div className="space-y-2">
                <div className="bg-muted h-4 w-full rounded"></div>
                <div className="bg-muted h-4 w-full rounded"></div>
                <div className="bg-muted h-4 w-5/6 rounded"></div>
              </div>
            </div>

            {/* Starring (Actors) Placeholder */}
            <div className="space-y-2">
              <div className="bg-muted h-6 w-1/4 rounded"></div>{" "}
              {/* Starring Title */}
              <div className="space-y-2">
                <div className="bg-muted h-4 w-full rounded"></div>
                <div className="bg-muted h-4 w-5/6 rounded"></div>
              </div>
            </div>

            {/* Additional Details Placeholder */}
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-8 gap-y-6">
              {/* Detail Item */}
              <div className="space-y-1">
                <div className="bg-muted h-5 w-1/3 rounded"></div>{" "}
                {/* Detail Title */}
                <div className="bg-muted h-4 w-3/4 rounded"></div>{" "}
                {/* Detail Value */}
              </div>
              {/* Detail Item */}
              <div className="space-y-1">
                <div className="bg-muted h-5 w-1/3 rounded"></div>
                <div className="bg-muted h-4 w-3/4 rounded"></div>
              </div>
              {/* Detail Item */}
              <div className="space-y-1">
                <div className="bg-muted h-5 w-1/3 rounded"></div>
                <div className="bg-muted h-4 w-1/2 rounded"></div>
              </div>
              {/* Detail Item */}
              <div className="space-y-1">
                <div className="bg-muted h-5 w-1/3 rounded"></div>
                <div className="bg-muted h-4 w-1/2 rounded"></div>
              </div>
              {/* Detail Item */}
              <div className="space-y-1">
                <div className="bg-muted h-5 w-1/3 rounded"></div>
                <div className="bg-muted h-4 w-1/2 rounded"></div>
              </div>
              {/* Detail Item */}
              <div className="space-y-1">
                <div className="bg-muted h-5 w-1/3 rounded"></div>
                <div className="bg-muted h-4 w-1/2 rounded"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  output: 'standalone',
  images: {
    remotePatterns: [
      {
        protocol: "https",
        hostname: "image.tmdb.org",
        port: "",
        pathname: "/t/p/**",
      }
    ]
  }
};

export default nextConfig;
</file>

<file path="app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.129 0.042 264.695);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.129 0.042 264.695);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.129 0.042 264.695);
  --primary: oklch(0.208 0.042 265.755);
  --primary-foreground: oklch(0.984 0.003 247.858);
  --secondary: oklch(0.968 0.007 247.896);
  --secondary-foreground: oklch(0.208 0.042 265.755);
  --muted: oklch(0.968 0.007 247.896);
  --muted-foreground: oklch(0.554 0.046 257.417);
  --accent: oklch(0.968 0.007 247.896);
  --accent-foreground: oklch(0.208 0.042 265.755);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.929 0.013 255.508);
  --input: oklch(0.929 0.013 255.508);
  --ring: oklch(0.704 0.04 256.788);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.984 0.003 247.858);
  --sidebar-foreground: oklch(0.129 0.042 264.695);
  --sidebar-primary: oklch(0.208 0.042 265.755);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.968 0.007 247.896);
  --sidebar-accent-foreground: oklch(0.208 0.042 265.755);
  --sidebar-border: oklch(0.929 0.013 255.508);
  --sidebar-ring: oklch(0.704 0.04 256.788);
}

.dark {
  --background: oklch(0.129 0.042 264.695);
  --foreground: oklch(0.984 0.003 247.858);
  --card: oklch(0.208 0.042 265.755);
  --card-foreground: oklch(0.984 0.003 247.858);
  --popover: oklch(0.208 0.042 265.755);
  --popover-foreground: oklch(0.984 0.003 247.858);
  --primary: oklch(0.929 0.013 255.508);
  --primary-foreground: oklch(0.208 0.042 265.755);
  --secondary: oklch(0.279 0.041 260.031);
  --secondary-foreground: oklch(0.984 0.003 247.858);
  --muted: oklch(0.279 0.041 260.031);
  --muted-foreground: oklch(0.704 0.04 256.788);
  --accent: oklch(0.279 0.041 260.031);
  --accent-foreground: oklch(0.984 0.003 247.858);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.551 0.027 264.364);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.208 0.042 265.755);
  --sidebar-foreground: oklch(0.984 0.003 247.858);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.279 0.041 260.031);
  --sidebar-accent-foreground: oklch(0.984 0.003 247.858);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.551 0.027 264.364);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@layer utilities {
  .no-scrollbar::-webkit-scrollbar {
    display: none;
  }
  .no-scrollbar {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
}

/* Animation Utilities */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.animate-fade-in {
  animation: fadeIn 0.3s ease-out forwards;
}

.animate-scale-in {
  animation: scaleIn 0.2s ease-out forwards;
}

.hover-lift {
  transition: transform 0.2s ease-out;
}

.hover-lift:hover {
  transform: translateY(-4px);
}

.page-transition {
  animation: fadeIn 0.4s ease-out;
}
</file>

<file path="components/MediaCard.tsx">
import Image from "next/image";
import { Badge } from "@/components/ui/badge";
import { MediaItem } from "@/lib/tmdb";
import Link from "next/link";

interface MediaCardProps {
  item: MediaItem;
  mediaType: "movie" | "tv";
}

const IMAGE_BASE_URL = process.env.NEXT_PUBLIC_TMDB_IMAGE_BASE_URL || "https://image.tmdb.org/t/p/w500";

export function MediaCard({ item, mediaType }: MediaCardProps) {
  const title = mediaType === "movie" ? item.title : item.name;
  const releaseDate = mediaType === "movie" ? item.release_date : item.first_air_date;
  const year = releaseDate ? new Date(releaseDate).getFullYear() : "N/A";
  const rating = item.vote_average ? item.vote_average.toFixed(1) : "N/A";

  const href = mediaType === "movie" 
    ? `/movies/detail/${item.id}` 
    : `/shows/${item.id}`;

  return (
    <Link href={href} className="block" prefetch={false}>
      <div className="w-36 sm:w-40 md:w-44 flex flex-col flex-shrink-0 rounded-lg shadow-md overflow-hidden bg-card hover-lift animate-fade-in">
        <div
          className="relative w-full overflow-hidden rounded-t-lg"
          style={{ paddingBottom: "150%" }}
        >
          {item.poster_path ? (
            <Image
              src={`${IMAGE_BASE_URL}${item.poster_path}`}
              alt={title || "Media Poster"}
              fill
              className="object-cover transition-transform duration-300 hover:scale-105"
              sizes="(min-width: 768px) 176px, (min-width: 640px) 160px, 144px"
            />
          ) : (
            <div className="absolute inset-0 flex items-center justify-center bg-slate-200 dark:bg-slate-700">
              <span className="text-xs text-slate-500 dark:text-slate-400 text-center p-1">
                No Poster
              </span>
            </div>
          )}
        </div>
        <div className="p-2 flex flex-col flex-grow bg-card-foreground/5 dark:bg-card-foreground/10">
          <div
            className="text-sm font-semibold leading-tight mb-0.5 truncate text-card-foreground transition-colors duration-200"
            title={title || "Untitled"}
          >
            {title || "Untitled"}
          </div>
          <div className="text-xs text-muted-foreground mb-1.5 transition-colors duration-200">{year}</div>
          <div className="mt-auto">
            <Badge
              variant={
                parseFloat(rating) >= 7
                  ? "default"
                  : parseFloat(rating) >= 5
                  ? "secondary"
                  : "destructive"
              }
              className="text-[10px] px-1.5 py-0.5 transition-all duration-200 hover:scale-105"
            >
              ★ {rating}
            </Badge>
          </div>
        </div>
      </div>
    </Link>
  );
}
</file>

<file path="app/movies/detail/[id]/page.tsx">
// app/movies/detail/[id]/page.tsx
import Image from "next/image";
import {
  getMovieDetails,
  getMovieCredits,
  CastMember,
  CrewMember,
  MediaItem,
} from "@/lib/tmdb";
import { Badge } from "@/components/ui/badge";
import { PaginationLink } from "@/components/ui/pagination";
import { notFound } from "next/navigation";
import { WatchlistButton } from "@/components/watchlist-button";
import { createClient } from "@/lib/supabase/server";
// import { isMovieInWatchlist } from "@/app/watchlist/actions"; // No longer needed for server-side check here
import type { Metadata } from "next";

const IMAGE_BASE_URL =
  process.env.NEXT_PUBLIC_TMDB_IMAGE_BASE_URL ||
  "https://image.tmdb.org/t/p/original";

const findCrewMembers = (
  crew: CrewMember[],
  job: string,
  limit: number = 2
): string[] => {
  return crew
    .filter((member) => member.job === job)
    .slice(0, limit)
    .map((member) => member.name);
};

const getTopCast = (cast: CastMember[], limit: number = 5): string[] => {
  return cast
    .sort((a, b) => a.order - b.order)
    .slice(0, limit)
    .map((member) => member.name);
};

export async function generateMetadata({
  params: paramsPromise,
}: {
  params: Promise<{ id: string }>;
}): Promise<Metadata> {
  const params = await paramsPromise;
  const movieIdStr = params.id;

  try {
    const movie = await getMovieDetails(movieIdStr);
    if (!movie || !movie.title) {
      return {
        title: "Movie Details | SceneIt",
        description: "Detailed information about a movie.",
      };
    }
    return {
      title: `${movie.title} | SceneIt`,
      description: movie.overview || `Details for the movie ${movie.title}.`,
      openGraph: {
        title: `${movie.title} | SceneIt`,
        description: movie.overview || `Details for the movie ${movie.title}.`,
        images: movie.poster_path
          ? [`${IMAGE_BASE_URL}${movie.poster_path}`]
          : [],
      },
    };
  } catch (error) {
    console.error(
      "Failed to generate metadata for movie ID:",
      movieIdStr,
      error
    );
    return {
      title: "Movie Details | SceneIt",
      description: "Detailed information about a movie.",
    };
  }
}

export default async function MoviePage({
  params: paramsPromise,
}: {
  params: Promise<{ id: string }>;
}) {
  const params = await paramsPromise;
  const movieIdStr = params.id;
  const movieIdNum = parseInt(movieIdStr, 10);

  if (isNaN(movieIdNum)) {
    console.error("Invalid movie ID format:", movieIdStr);
    notFound();
  }

  let movie: MediaItem | null = null;
  let credits: { cast: CastMember[]; crew: CrewMember[] } | null = null;

  try {
    const [movieData, creditsData] = await Promise.all([
      getMovieDetails(movieIdStr),
      getMovieCredits(movieIdStr),
    ]);
    movie = movieData;
    credits = creditsData;
  } catch (error) {
    console.error(
      "Failed to fetch movie data or credits for ID:",
      movieIdStr,
      error
    );
  }

  if (!movie || !movie.id || !credits) {
    console.error(
      "Movie or credits data is missing or incomplete for ID:",
      movieIdStr
    );
    notFound();
  }

  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser(); // Still fetch user to pass to WatchlistButton

  // REMOVED: Server-side watchlist check
  // let initialIsInWatchlist: boolean | undefined = undefined;
  // if (user) {
  //   initialIsInWatchlist = await isMovieInWatchlist(movieIdNum);
  // } else {
  //   initialIsInWatchlist = false;
  // }

  const releaseDate = movie.release_date
    ? new Date(movie.release_date).toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      })
    : "Release date unknown";

  const runtime = movie.runtime
    ? `${Math.floor(movie.runtime / 60)}h ${movie.runtime % 60}m`
    : "Runtime unknown";

  const rating = movie.vote_average?.toFixed(1) || "N/A";

  const directors = findCrewMembers(credits.crew, "Director");
  const producers = findCrewMembers(credits.crew, "Producer", 3);
  const actors = getTopCast(credits.cast, 6);

  return (
    <main className="container mx-auto px-4 py-8 page-transition">
      <div className="flex flex-col gap-8">
        <div>
          <PaginationLink href="/" size="sm" className="text-sm">
            ← Back to Home
          </PaginationLink>
        </div>

        <div className="flex flex-col md:flex-row gap-8">
          <div className="w-full md:w-1/3 lg:w-1/4 flex-shrink-0">
            <div className="relative aspect-[2/3] rounded-lg overflow-hidden shadow-lg">
              {movie.poster_path ? (
                <Image
                  src={`${IMAGE_BASE_URL}${movie.poster_path}`}
                  alt={movie.title || "Movie Poster"}
                  fill
                  className="object-cover"
                  sizes="(min-width: 1024px) 25vw, (min-width: 768px) 33vw, 100vw"
                  priority
                />
              ) : (
                <div className="absolute inset-0 flex items-center justify-center bg-slate-200 dark:bg-slate-700">
                  <span className="text-slate-500 dark:text-slate-400">
                    No Poster Available
                  </span>
                </div>
              )}
            </div>
          </div>

          <div className="flex-1">
            <h1 className="text-4xl font-bold mb-4">{movie.title}</h1>
            {movie.tagline && (
              <p className="text-lg text-muted-foreground italic mb-4">
                &quot;{movie.tagline}&quot;
              </p>
            )}

            {/* NEW Combined container for Badges and Watchlist Button */}
            {/* - Stacks vertically on small screens (flex-col) with gap-y-6 (24px) */}
            {/* - Arranges horizontally on sm screens and up (sm:flex-row) with gap-x-6 (24px) */}
            {/* - Vertically centers items when horizontal (sm:items-center) */}
            {/* - Maintains bottom margin before next section (mb-6) */}
            <div className="flex flex-col sm:flex-row sm:items-center gap-x-6 gap-y-6 mb-6">
              {/* Badges Section */}
              <div className="flex flex-wrap gap-3">
                <Badge variant="outline">{releaseDate}</Badge>
                <Badge variant="outline">{runtime}</Badge>
                <Badge
                  variant={
                    parseFloat(rating) >= 7
                      ? "default"
                      : parseFloat(rating) >= 5
                      ? "secondary"
                      : "destructive"
                  }
                >
                  ★ {rating}
                </Badge>
                {movie.status && <Badge variant="outline">{movie.status}</Badge>}
              </div>

              {/* Watchlist Button Section Wrapper */}
              {/* - On sm screens and up, pushes to the far right of this flex container (sm:ml-auto) */}
              {/* - Wrapper takes full width on small screens, auto width on sm+ */}
              <div className="w-full sm:w-auto sm:ml-auto">
                <WatchlistButton
                  movieId={movieIdNum}
                  user={user}
                  className="w-full sm:w-auto" // Button fills its wrapper
                  size="lg" // Keeps the button visually large as before
                />
              </div>
            </div>

            {movie.genres && movie.genres.length > 0 && (
              <div className="mb-6">
                <h2 className="text-lg font-semibold mb-2">Genres</h2>
                <div className="flex flex-wrap gap-2">
                  {movie.genres.map((genre) => (
                    <Badge key={genre.id} variant="secondary">
                      {genre.name}
                    </Badge>
                  ))}
                </div>
              </div>
            )}

            {movie.overview && (
              <div className="mb-6">
                <h2 className="text-lg font-semibold mb-2">Overview</h2>
                <p className="text-muted-foreground">{movie.overview}</p>
              </div>
            )}

            {actors.length > 0 && (
              <div className="mb-6">
                <h2 className="text-lg font-semibold mb-2">Starring</h2>
                <p className="text-muted-foreground">{actors.join(", ")}</p>
              </div>
            )}

            <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-8 gap-y-4">
              {directors.length > 0 && (
                <div>
                  <h2 className="text-sm font-semibold">Directed by</h2>
                  <p className="text-muted-foreground">
                    {directors.join(", ")}
                  </p>
                </div>
              )}
              {producers.length > 0 && (
                <div>
                  <h2 className="text-sm font-semibold">Produced by</h2>
                  <p className="text-muted-foreground">
                    {producers.join(", ")}
                  </p>
                </div>
              )}
              {movie.original_language && (
                <div>
                  <h2 className="text-sm font-semibold">Language</h2>
                  <p className="text-muted-foreground">
                    {movie.original_language.toUpperCase()}
                  </p>
                </div>
              )}
              {movie.production_countries &&
                movie.production_countries.length > 0 && (
                  <div>
                    <h2 className="text-sm font-semibold">Country</h2>
                    <p className="text-muted-foreground">
                      {movie.production_countries
                        .map((country) => country.name)
                        .join(", ")}
                    </p>
                  </div>
                )}
              {movie.budget !== undefined && movie.budget > 0 && (
                <div>
                  <h2 className="text-sm font-semibold">Budget</h2>
                  <p className="text-muted-foreground">
                    ${movie.budget.toLocaleString("en-US")}
                  </p>
                </div>
              )}
              {movie.revenue !== undefined && movie.revenue > 0 && (
                <div>
                  <h2 className="text-sm font-semibold">Revenue</h2>
                  <p className="text-muted-foreground">
                    ${movie.revenue.toLocaleString("en-US")}
                  </p>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </main>
  );
}
</file>

<file path="app/page.tsx">
// app/page.tsx
import { MediaGrid } from "@/components/MediaGrid";
import {
  getPopularMovies,
  getTopRatedMovies,
  getUpcomingMovies,
  getNowPlayingMovies,
} from "@/lib/tmdb";

export default async function HomePage() {
  const [
    popularMoviesData,
    topRatedMoviesData,
    upcomingMoviesData,
    nowPlayingMoviesData,
  ] = await Promise.all([
    getPopularMovies(),
    getTopRatedMovies(),
    getUpcomingMovies(),
    getNowPlayingMovies(),
  ]);

  const popularMovies = popularMoviesData?.results || [];
  const topRatedMovies = topRatedMoviesData?.results || [];
  const upcomingMovies = upcomingMoviesData?.results || [];
  const nowPlayingMovies = nowPlayingMoviesData?.results || [];

  return (
    <main className="container mx-auto px-4 py-8 page-transition">
      {/* Movies Section */}
      <div className="animate-scale-in">
        <MediaGrid
          items={nowPlayingMovies}
          mediaType="movie"
          title="Now Playing Movies"
          moreLinkHref="/movies/now-playing"
        />
        <MediaGrid
          items={popularMovies}
          mediaType="movie"
          title="Popular Movies"
          moreLinkHref="/movies/popular"
        />
        <MediaGrid
          items={upcomingMovies}
          mediaType="movie"
          title="Upcoming Movies"
          moreLinkHref="/movies/upcoming"
        />
        <MediaGrid
          items={topRatedMovies}
          mediaType="movie"
          title="Top Rated Movies"
          moreLinkHref="/movies/top-rated"
        />
      </div>
    </main>
  );
}
</file>

<file path="lib/tmdb.ts">
const API_KEY = process.env.TMDB_API_KEY;
const BASE_URL = "https://api.themoviedb.org/3";

interface FetchOptions extends RequestInit {
  params?: Record<string, string | number | boolean>;
}

async function fetchTMDB(endpoint: string, options: FetchOptions = {}) {
  const params = new URLSearchParams(options.params as Record<string, string>);
  const url = `${BASE_URL}/${endpoint}?api_key=${API_KEY}&${params.toString()}`;

  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        "Content-Type": "application/json",
      },
      next: { revalidate: 3600 },
    });

    if (!response.ok) {
      console.error(
        `TMDB API Error: ${response.status} ${response.statusText} for URL: ${url}`
      );
      const errorBody = await response
        .json()
        .catch(() => ({ message: "Failed to parse error response" }));
      console.error("Error details:", errorBody);
      throw new Error(
        `Failed to fetch data from TMDB: ${
          errorBody.message || response.statusText
        }`
      );
    }
    return response.json();
  } catch (error) {
    console.error(`Error in fetchTMDB for endpoint ${endpoint}:`, error);
    return { results: [], page: 0, total_pages: 0, total_results: 0 };
  }
}

function getCurrentDateFormatted(): string {
  const today = new Date();
  const year = today.getFullYear();
  const month = (today.getMonth() + 1).toString().padStart(2, "0");
  const day = today.getDate().toString().padStart(2, "0");
  return `${year}-${month}-${day}`;
}

function getEndOfCurrentYearFormatted(): string {
  const today = new Date();
  const year = today.getFullYear();
  return `${year}-12-31`;
}

export interface MediaItem {
  id: number;
  poster_path: string | null;
  backdrop_path: string | null;
  title?: string;
  name?: string;
  release_date?: string;
  first_air_date?: string;
  vote_average: number;
  overview: string;
  runtime?: number;
  status?: string;
  genres?: { id: number; name: string }[];
  original_language?: string;
  production_countries?: { iso_3166_1: string; name: string }[];
  budget?: number;
  revenue?: number;
  tagline?: string;
}

export interface TMDBResponse {
  page: number;
  results: MediaItem[];
  total_pages: number;
  total_results: number;
}

export async function getMovieDetails(movieId: string): Promise<MediaItem> {
  return fetchTMDB(`movie/${movieId}`);
}

export async function getNowPlayingMovies(
  page: number = 1
): Promise<TMDBResponse> {
  return fetchTMDB("movie/now_playing", { params: { page } });
}

export async function getPopularMovies(
  page: number = 1
): Promise<TMDBResponse> {
  return fetchTMDB("movie/popular", { params: { page } });
}

export async function getTopRatedMovies(
  page: number = 1
): Promise<TMDBResponse> {
  return fetchTMDB("movie/top_rated", { params: { page } });
}

export async function getUpcomingMovies(
  page: number = 1
): Promise<TMDBResponse> {
  const currentDate = getCurrentDateFormatted();
  const endOfYear = getEndOfCurrentYearFormatted();
  return fetchTMDB("discover/movie", {
    params: {
      page,
      "primary_release_date.gte": currentDate,
      "primary_release_date.lte": endOfYear,
      sort_by: "popularity.desc",
    },
  });
}

export interface CastMember {
  id: number;
  name: string;
  character: string;
  profile_path: string | null;
  order: number; // The order of the cast member in the credits
}

export interface CrewMember {
  id: number;
  name: string;
  job: string; // e.g., "Director", "Producer"
  department: string;
}

export interface CreditsResponse {
  id: number; // Movie ID
  cast: CastMember[];
  crew: CrewMember[];
}

export async function getMovieCredits(
  movieId: string
): Promise<CreditsResponse> {
  return fetchTMDB(`movie/${movieId}/credits`);
}

export interface MediaItem {
  id: number;
  poster_path: string | null;
  backdrop_path: string | null;
  title?: string; // Movie title
  name?: string; // TV show name
  release_date?: string;
  first_air_date?: string;
  vote_average: number;
  overview: string;
  runtime?: number;
  status?: string;
  genres?: { id: number; name: string }[];
  original_language?: string;
  production_countries?: { iso_3166_1: string; name: string }[];
  budget?: number;
  revenue?: number;
  tagline?: string;
  media_type?: "movie" /* | 'tv' | 'person' */; // Useful for search/multi
}

export async function searchMovies(
  query: string,
  page: number = 1
): Promise<TMDBResponse> {
  if (!query.trim()) {
    // Return an empty response if the query is empty to avoid unnecessary API calls
    // and handle it gracefully on the search page.
    return { page: 1, results: [], total_pages: 0, total_results: 0 };
  }
  return fetchTMDB("search/movie", {
    params: { query, page, include_adult: false },
  });
}
</file>

<file path="README.md">
# SceneIt 🎬

SceneIt is a modern movie tracking web application that allows users to discover, search, and keep track of movies they want to watch. Built with Next.js, Supabase, and the TMDB API, it offers a sleek, responsive interface with features like user authentication, personalized watchlists, and detailed movie information.

Live - https://sceneit.yatin-ys.tech/

## ✨ Features

*   **Comprehensive Movie Browsing:**
    *   Discover "Now Playing", "Popular", "Upcoming", and "Top Rated" movies.
    *   Paginated category pages for extensive browsing.
*   **Detailed Movie Information:**
    *   View movie posters, titles, taglines, release dates, runtimes, and ratings.
    *   Access summaries, genre tags, cast and crew (directors, producers) lists.
    *   See details like original language, production countries, budget, and revenue.
*   **Powerful Search:**
    *   Quickly find movies using the integrated search bar.
    *   Paginated search results for easy navigation.
*   **User Authentication:**
    *   Secure sign-up and sign-in with email/password or Google OAuth.
    *   Email confirmation for new accounts.
*   **Personalized Watchlist:**
    *   Add movies to a personal watchlist.
    *   Remove movies from the watchlist.
    *   Dedicated page to view all movies in your watchlist.
*   **User Profile Management:**
    *   View account details (email, display name, join date).
    *   Update your display name.
    *   Change password (for email/password authenticated users).
*   **Modern UI/UX:**
    *   Sleek and responsive design, adaptable to all screen sizes.
    *   Dark mode support.
    *   Loading skeletons for a smoother browsing experience.
    *   Toast notifications for user feedback on actions.
    *   Smooth page transitions and hover effects.

## 🛠️ Tech Stack

*   **Framework:** Next.js 15 (App Router)
*   **UI Library:** React 19
*   **Language:** TypeScript
*   **Styling:** Tailwind CSS 4
*   **Components:** Shadcn UI
*   **Backend & Auth:** Supabase (Authentication, Database, SSR Helpers)
*   **Movie Data:** TMDB API
*   **Deployment:** Vercel
</file>

<file path="package.json">
{
  "name": "scene-it",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "preview": "opennextjs-cloudflare build && opennextjs-cloudflare preview",
    "deploy": "opennextjs-cloudflare build && opennextjs-cloudflare deploy",
    "cf-typegen": "wrangler types --env-interface CloudflareEnv cloudflare-env.d.ts"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.0.1",
    "@opennextjs/cloudflare": "^1.1.0",
    "@radix-ui/react-aspect-ratio": "^1.1.7",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-tabs": "^1.1.12",
    "@supabase/ssr": "^0.6.1",
    "@supabase/supabase-js": "^2.49.8",
    "@vercel/analytics": "^1.5.0",
    "@vercel/speed-insights": "^1.2.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.511.0",
    "next": "15.3.2",
    "next-themes": "^0.4.6",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.56.4",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.3.0",
    "zod": "^3.25.36"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/cookie": "^0.6.0",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.2",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.0",
    "typescript": "^5",
    "wrangler": "^4.18.0"
  }
}
</file>

<file path="app/layout.tsx">
// app/layout.tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { ThemeProvider } from "@/components/theme-provider";
import { DarkModeToggle } from "@/components/dark-mode-toggle";
import "./globals.css";
import Link from "next/link";
import { Suspense } from "react";
import { SearchInput } from "@/components/SearchInput";
import { Analytics } from '@vercel/analytics/next';
import { SpeedInsights } from '@vercel/speed-insights/next';
import { Toaster } from "@/components/ui/sonner";
import { UserButton } from "@/components/auth/user-button";
import { createClient } from "@/lib/supabase/server";
import { Footer } from "@/components/footer";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "SceneIt",
  description: "Movie tracking web app.",
};

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased min-h-screen flex flex-col`}
      >
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
            <nav className="container mx-auto px-4 h-16 flex items-center justify-between gap-4">
              <div className="flex items-center gap-4 lg:gap-6 flex-1">
                <Link 
                  href="/" 
                  className="flex items-center gap-2 transition-transform hover:scale-105"
                >
                  <h1 className="text-2xl font-bold tracking-tight">
                    SceneIt
                  </h1>
                </Link>
                <div className="hidden sm:block w-full max-w-md">
                  <Suspense fallback={null}>
                    <SearchInput />
                  </Suspense>
                </div>
              </div>

              <div className="flex items-center gap-2">
                <UserButton user={user} />
                <DarkModeToggle />
              </div>
            </nav>
            <div className="sm:hidden container mx-auto px-4 pb-4">
              <Suspense fallback={null}>
                <SearchInput />
              </Suspense>
            </div>
          </header>

          <main className="flex-grow container mx-auto px-4 pb-8">
            {children}
          </main>

          <Footer />
          <Toaster richColors closeButton />
        </ThemeProvider>
        <Analytics />
        <SpeedInsights />
      </body>
    </html>
  );
}
</file>

</files>
